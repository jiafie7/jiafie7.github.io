[{"content":"438. 找到字符串中所有字母异位词 分析 初始化目标频率表：\n使用哈希表 hash 存储字符串 p 中每个字符的频率 滑动窗口遍历字符串 s：\n窗口初始范围为 [j, i]，窗口长度不超过 p.size() 遍历字符串 s，对窗口内的字符更新哈希表： 窗口右扩（加入字符）： 将当前字符 s[i] 加入窗口，并在 hash 中减少其频率 如果该字符的频率变为 0，说明该字符的频率匹配，增加匹配计数 count 窗口左缩（移除字符）： 如果窗口长度超过 p.size()，将左端字符 s[j] 从窗口移除： 如果 s[j] 在 hash 中频率变为非零，匹配计数 count 减少 更新左指针 j 判断异位词：\n如果窗口内所有字符频率均匹配（count == total），将当前窗口左端索引 j 加入结果集 res 时间复杂度 初始化哈希表：O(p)，其中 p 是字符串 p 的长度 滑动窗口遍历：O(s)，其中 s 是字符串 s 的长度 总时间复杂度：O(s + p)\n空间复杂度 使用了一个哈希表存储字符频率，空间复杂度为 O(k)，其中 k 是字符集大小\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { std::unordered_map\u0026lt;char, int\u0026gt; hash; // 存储目标字符频率 for (char c : p) ++hash[c]; std::vector\u0026lt;int\u0026gt; res; int total = hash.size(), count = 0; for (int i = 0, j = 0; i \u0026lt; s.size(); ++ i) { // 右扩：加入字符 s[i] -- hash[s[i]]; if (hash[s[i]] == 0) ++ count; // 左缩：移除字符 s[j] if (i - j + 1 \u0026gt; p.size()) { if (hash[s[j]] == 0) -- count; ++ hash[s[j]]; ++ j; } // 检查是否找到异位词 if (count == total) res.push_back(j); } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/findanagrams/","title":"findAnagrams"},{"content":"3. 无重复字符的最长子串 分析 维护一个滑动窗口： 滑动窗口用两个指针表示，j 为窗口左端，i 为窗口右端 窗口内的子串为 [j, i]，保证该窗口内没有重复字符 使用哈希表记录字符出现的次数： 哈希表 hash 的 key 为字符，value 为该字符在窗口中的出现次数 移动窗口右端： 遍历字符串，右端指针 i 每次右移一格，将字符加入窗口并更新哈希表 处理重复字符： 如果窗口中出现重复字符（即当前字符的出现次数大于 1），移动左端指针 j，并在哈希表中移除字符，直到窗口内没有重复字符。 更新结果： 每次移动窗口时，计算当前窗口的长度 (i - j + 1)，并更新结果 res 时间复杂度 每个字符至多被访问两次（右指针扩展时访问一次，左指针收缩时访问一次），时间复杂度为 O(n)\n空间复杂度 使用哈希表存储字符出现次数，空间复杂度为 O(k)，其中 k 为字符集大小\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int lengthOfLongestSubstring(string s) { std::unordered_map\u0026lt;char, int\u0026gt; hash; // 记录字符出现次数 int res = 0; // 最长子串长度 for (int i = 0, j = 0; i \u0026lt; s.size(); ++ i) { ++hash[s[i]]; // 将字符加入窗口 // 如果出现重复字符，移动左指针 j while (hash[s[i]] \u0026gt; 1) { -- hash[s[j]]; ++ j; } // 更新最长子串长度 res = std::max(res, i - j + 1); } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/lengthoflongestsubstring/","title":"lengthOfLongestSubstring"},{"content":"239. 滑动窗口最大值 分析 维护一个单调递减队列：\n使用一个双端队列 q 存储数组的索引 队列中的元素对应的值保持单调递减顺序，队首始终是当前窗口的最大值索引 窗口滑动的处理：\n窗口失效处理：检查队首索引是否超出当前窗口范围 (i - k + 1)，若超出则弹出队首 保持单调性：将新元素加入队列时，弹出队列中所有小于当前元素值的索引，以确保队列的单调递减性 记录最大值：当窗口的大小达到 k 时 (i \u0026gt;= k - 1)，窗口的最大值即为队首索引对应的值 时间复杂度 遍历数组：所有元素仅被插入和弹出队列一次，时间复杂度为 O(n) 队列操作：每次插入和弹出操作的平均时间复杂度为 O(1) 总时间复杂度：O(n)\n空间复杂度 使用了一个双端队列存储索引，空间复杂度为 O(k)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::deque\u0026lt;int\u0026gt; q; // 双端队列存储索引 std::vector\u0026lt;int\u0026gt; res; // 存储结果 for (int i = 0; i \u0026lt; nums.size(); ++i) { // 移除队首超出窗口范围的元素 if (q.size() \u0026amp;\u0026amp; q.front() \u0026lt; i - k + 1) q.pop_front(); // 保持队列单调递减 while (q.size() \u0026amp;\u0026amp; nums[q.back()] \u0026lt;= nums[i]) q.pop_back(); // 添加当前元素索引到队列 q.push_back(i); // 当窗口形成时，记录窗口最大值 if (i \u0026gt;= k - 1) res.push_back(nums[q.front()]); } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxslidingwindow/","title":"maxSlidingWindow"},{"content":"76. 最小覆盖子串 分析 记录目标字符频率： 使用哈希表 hashT 记录字符串 t 中每个字符的频率。 维护当前窗口的字符频率： 使用另一个哈希表 hashS 记录当前窗口内字符的频率。 滑动窗口： 扩展窗口：从左到右遍历字符串 s，将当前字符加入窗口，并更新 hashS 满足条件：当窗口中的字符满足 t 中的所有字符（包括频率要求），记录当前窗口长度 收缩窗口：尝试从窗口左端收缩，以找到更小的满足条件的子串 更新结果： 如果窗口当前覆盖所有所需字符且长度更短，则更新结果字符串 时间复杂度 遍历字符串 s：每个字符至多被访问两次（一次扩展窗口，一次收缩窗口），时间复杂度为 O(n) 更新哈希表：更新和查询哈希表的操作时间复杂度为 O(1) 总时间复杂度：O(n)\n空间复杂度 使用了两个哈希表存储字符频率，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: string minWindow(string s, string t) { std::unordered_map\u0026lt;char, int\u0026gt; hashS, hashT; for (char c : t) ++ hashT[c]; // 记录目标字符串 t 的字符频率 int cnt = 0; // 当前窗口内满足条件的字符个数 std::string res; // 记录结果子串 for (int i = 0, j = 0; i \u0026lt; s.size(); ++i) { ++ hashS[s[i]]; // 扩展窗口 if (hashS[s[i]] \u0026lt;= hashT[s[i]]) ++ cnt; // 更新满足条件的字符数 // 收缩窗口：移除多余的字符 while (hashS[s[j]] \u0026gt; hashT[s[j]]) { -- hashS[s[j]]; ++ j; } // 检查当前窗口是否满足条件 if (cnt == t.size()) if (res.empty() || res.size() \u0026gt; i - j + 1) res = s.substr(j, i - j + 1); // 更新结果 } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxwindow/","title":"maxWindow"},{"content":"560. 和为k的子数组 分析 定义前缀和：\n用 sum 表示从数组起点到当前位置的元素总和 任意连续子数组的和可以通过前缀和的差来计算：sum[i] - sum[j] = k =\u0026gt; sum[i] - k = sum[j] 使用哈希表存储前缀和出现的次数：\n哈希表 hash 的键表示前缀和的值，值表示该前缀和出现的次数 初始状态下，将前缀和 0 的计数置为 1（代表从起点到当前位置的子数组和可能为 k ） 遍历数组，动态更新结果：\n遍历数组中的每个元素，将当前值累加到 sum 检查 hash 中是否存在键 sum - k： 若存在，说明从某个之前的位置到当前的位置的子数组和为 k ，将其对应的次数累加到结果 res 中 更新 hash，增加当前前缀和 sum 的计数 返回结果：\n遍历结束后，结果 res 即为和为 k 的子数组个数 时间复杂度 遍历数组：O(n)，其中 n 是数组的长度 哈希表操作：平均时间复杂度为 O(1) 总时间复杂度：O(n)\n空间复杂度 使用了哈希表存储前缀和及其次数，空间复杂度为 O(n)，其中 n 是数组的长度\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::unordered_map\u0026lt;int, int\u0026gt; hash; // 存储前缀和及其出现次数 int res = 0, sum = 0; hash[0] = 1; // 初始化前缀和 0 的计数为 1 for (int num : nums) { sum += num; // 更新前缀和 res += hash[sum - k]; // 检查是否存在前缀和满足条件 ++ hash[sum]; // 更新当前前缀和的计数 } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/subarraysum/","title":"subarraySum"},{"content":"49. 字母异位词分组 分析 核心思想： 字母异位词在字母排序后，其排序结果是相同的。例如： \u0026quot;eat\u0026quot; 和 \u0026quot;tea\u0026quot; 排序后都为 \u0026quot;aet\u0026quot; 因此，可以将排序后的字符串作为键，将所有字母异位词分组存储在一个哈希表中 步骤： 遍历字符串数组，对每个字符串进行排序，得到其标准形式 将排序后的字符串作为键，将原始字符串加入到对应的哈希表键值中 遍历哈希表，提取所有的值（即字母异位词组） 时间复杂度 排序： 每个字符串排序的时间复杂度为 O(klogk) ，其中 k 是字符串的平均长度 总的排序复杂度为 O(n * klogk) ，其中 n 是字符串数组的大小 哈希表操作： 插入和查找操作的平均复杂度为 O(1) 总时间复杂度为 O(n * klogk)\n空间复杂度 哈希表存储：需要存储排序后的字符串和对应的原始字符串列表，空间复杂度为 O(n * k) 额外字符串副本：排序时需要创建字符串副本，额外空间复杂度为 O(k) 总空间复杂度为 O(n * k)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; groupAnagrams(std::vector\u0026lt;std::string\u0026gt;\u0026amp; strs) { std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; res; // 存储最终结果 std::unordered_map\u0026lt;std::string, std::vector\u0026lt;std::string\u0026gt;\u0026gt; hash; // 哈希表用于分组 // 遍历字符串数组 for (string str : strs) { std::string word = str; // 创建副本以便排序 std::sort(word.begin(), word.end()); // 排序字符串 hash[word].push_back(str); // 将原始字符串加入对应组 } // 遍历哈希表，将值部分（分组结果）加入结果 for (auto e : hash) res.push_back(e.second); return res; // 返回分组后的结果 } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/groupanagrams/","title":"groupAnagrams"},{"content":"128. 最长连续序列 分析 使用哈希集合 (unordered_set)：\n首先将数组中的所有元素存入一个哈希集合 s 中，便于快速判断某个数字是否存在 遍历数组，寻找序列起点：\n对于每个数字 start，如果 start - 1 不存在于集合中，说明它是某个连续序列的起点 从这个起点开始，逐步检查 start + 1, start + 2, … 是否存在于集合中，计算连续序列的长度 优化：删除已访问元素：\n在遍历过程中，一旦某个数字被处理，可以从集合中删除，避免后续重复处理 更新结果：\n记录所有连续序列的最大长度 时间复杂度 构建哈希集合：O(n) ，其中 n 是数组长度\n遍历数组：\n每个元素最多被访问两次（一次作为序列起点，一次作为序列中元素） 总复杂度为 O(n) 总时间复杂度为 O(n)\n空间复杂度 使用了一个哈希集合存储数组中的所有元素，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int longestConsecutive(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::unordered_set\u0026lt;int\u0026gt; s; // 哈希集合存储所有数字 for (int num : nums) s.insert(num); int res = 0; // 记录最长连续序列的长度 for (int start : nums) { // 如果 start 是序列的起点（前一个数字不存在） if (s.count(start) \u0026amp;\u0026amp; !s.count(start - 1)) { int end = start; // 初始化序列的起点 s.erase(end); // 移除起点，避免重复处理 // 找到当前序列的结尾 while (s.count(end + 1)) { end += 1; s.erase(end); // 同样移除，优化后续查询 } // 更新最长长度 res = std::max(res, end - start + 1); } } return res; } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longestconsecutivesequence/","title":"longestConsecutiveSequence"},{"content":"11. 盛最多水的容器 分析 容器的水量由两条垂线的较小高度和它们之间的水平距离决定，公式为：min(height[i], height[j]) * (j - i)\n初始时，将左右指针分别置于数组的两端 计算当前两条垂线能容纳的水量，并更新最大水量 移动高度较小的一侧的指针： 因为容器的水量由两条垂线的较小高度决定，移动较小高度的一侧可能增加更高的高度，从而得到更大的水量 当左右指针相遇时，遍历结束，最大水量即为结果 时间复杂度 指针遍历：每次移动一个指针，最多遍历数组一次，时间复杂度为 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = 0; // 存储最大水量 int i = 0, j = height.size() - 1; // 初始化左右指针 while (i \u0026lt; j) { // 计算当前容器的水量 res = std::max(res, std::min(height[i], height[j]) * (j - i)); // 移动高度较小的一侧 if (height[i] \u0026lt; height[j]) ++ i; else -- j; } return res; // 返回最大水量 } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxarea/","title":"maxArea"},{"content":"283. 移动零 分析 i 用于记录非零元素的位置 遍历数组时，将非零元素按顺序填入数组前部，并记录当前插入的位置 遍历完成后，数组前部已填满非零元素，后续位置全部填充 0 时间复杂度 遍历数组一次，时间复杂度为 O(n) 填充零的操作也是 O(n) ，但两者不重叠，总体为O(n) 空间复杂度 使用了两个指针变量，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = 0; // 指针 i，用于记录下一个非零元素的位置 // 1. 遍历数组，将所有非零元素依次放到前部 for (int num : nums) { if (num != 0) { nums[i++] = num; // 将非零元素放入 i 位置，并移动 i } } // 2. 将剩余位置填充为 0 while (i \u0026lt; nums.size()) { nums[i++] = 0; } } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/movezeroes/","title":"moveZeroes"},{"content":"42. 接雨水 分析 条件： 雨水的高度由当前柱子左右两边的最高柱子决定 能接的雨水量为两侧最高柱子中较小值减去当前柱子的高度 预处理左右最高高度： 左侧最高高度数组 (left_max)： 遍历数组，从左到右记录当前位置左侧的最高柱子 右侧最高高度数组 (right_max)： 遍历数组，从右到左记录当前位置右侧的最高柱子 计算雨水量： 遍历数组，每个位置接的雨水为 min(left_max[i], right_max[i]) - height[i] 累加所有位置的雨水量，得到最终结果 时间复杂度 构建 left_max 和 right_max：O(n) 计算雨水量：O(n) 总复杂度：O(n)\n空间复杂度 需要额外的两个数组存储 left_max 和 right_max，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int n = height.size(); if (n == 0) return 0; // 边界条件，空数组返回 0 // 1. 构建左侧最高高度数组 std::vector\u0026lt;int\u0026gt; left_max(n); left_max[0] = height[0]; for (int i = 1; i \u0026lt; n; ++i) left_max[i] = std::max(left_max[i - 1], height[i]); // 2. 构建右侧最高高度数组 std::vector\u0026lt;int\u0026gt; right_max(n); right_max[n - 1] = height[n - 1]; for (int i = n - 2; i \u0026gt;= 0; --i) right_max[i] = std::max(right_max[i + 1], height[i]); // 3. 计算总雨水量 int res = 0; for (int i = 0; i \u0026lt; n; ++i) res += std::min(left_max[i], right_max[i]) - height[i]; return res; } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/trap/","title":"trap"},{"content":"31. LRUCache 分析 LRU（Least Recently Used）是一种缓存替换策略，淘汰最久未被使用的数据，以保证缓存内存的有效利用率\n核心数据结构：\n双向链表：维护缓存访问顺序，最新使用的数据放在链表头，最久未使用的数据放在链表尾。双向链表的插入和删除操作可以在 O(1) 时间内完成，适用于缓存频繁更新的场景 哈希表：通过关键字快速定位链表中的节点 get(key)：\n若 key 存在，将对应节点移动到链表头，并返回其值 若 key 不存在，返回 -1 put(key, value)：\n若 key 已存在，更新其值并移动到链表头 若 key 不存在： 如果缓存已满，删除链表尾的节点（最久未使用） 将新节点插入到链表头 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class LRUCache { public: // 定义双向链表节点 struct Node { Node(int key, int value) : m_key(key), m_value(value) , prev(nullptr), next(nullptr) {} int m_key, m_value; Node *prev, *next; }; int n; // 缓存容量 Node *head, *tail; // 双链表的虚拟头节点 std::unordered_map\u0026lt;int, Node*\u0026gt; hash; // 哈希表，快速查找节点 // 初始化 LRU 缓存 LRUCache(int capacity) { n = capacity; head = new Node(-1, -1); // 创建虚拟头节点 tail = new Node(-1, -1); // 创建虚拟尾节点 head-\u0026gt;next = tail; // 初始化双向链表 tail-\u0026gt;prev = head; } // 从链表中删除指定节点 void remove(Node* cur) { cur-\u0026gt;next-\u0026gt;prev = cur-\u0026gt;prev; cur-\u0026gt;prev-\u0026gt;next = cur-\u0026gt;next; } // 在链表头部插入指定节点 void insert(Node* cur) { cur-\u0026gt;next = head-\u0026gt;next; cur-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = cur; head-\u0026gt;next = cur; } // 获取节点的值 int get(int key) { if (!hash.count(key)) // 节点不存在 return -1; Node* cur = hash[key]; // 定位节点 remove(cur); // 更新节点在链表中的位置 insert(cur); return cur-\u0026gt;m_value; } // 插入或更新节点 void put(int key, int value) { if (hash.count(key)) // 节点已存在 { Node* cur = hash[key]; cur-\u0026gt;m_value = value; // 更新节点值 remove(cur); // 更新节点位置 insert(cur); } else // 节点不存在 { if (hash.size() == n) // 缓存已满 { Node* cur = tail-\u0026gt;prev; // 取出尾节点 remove(cur); // 从链表中移除 hash.erase(cur-\u0026gt;m_key); // 从哈希表中删除 } Node* cur = new Node(key, value); // 创建新节点 insert(cur); // 插入链表头 hash[key] = cur; // 添加到哈希表 } } }; ","date":"2024-11-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/lrucache/","title":"LRUCache"},{"content":"56. mergeIntervals 分析 排序： 首先将所有区间按照起始值从小到大排序。排序后，若两个区间有重叠，它们一定是相邻的 遍历与合并： 用变量 l 和 r 分别表示当前合并区间的起始和结束 遍历排序后的区间： 如果当前遍历区间的起始值大于当前合并区间的结束值 r，说明当前区间与前面的合并区间没有重叠，应将前面的合并区间加入结果，并更新 l 和 r 如果有重叠，则将 r 更新为当前区间结束值的较大值 遍历结束后，将最后一个合并区间加入结果 时间复杂度 排序：O(nlogn) ，n 是区间的数量 遍历：O(n)，每个区间只会被处理一次 总时间复杂度为 O(nlogn)\n空间复杂度 排序所需的额外空间复杂度为 O(logn) （排序算法的递归栈空间） 结果存储的空间复杂度为 O(n) 总空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 用于存储最终结果 if (intervals.empty()) return res; // 如果输入为空，直接返回空数组 // 1. 按区间的起始值排序 sort(intervals.begin(), intervals.end()); // 2. 初始化合并区间的左右边界 int l = intervals[0][0], r = intervals[0][1]; // 3. 遍历剩余区间 for (int i = 1; i \u0026lt; intervals.size(); ++ i) { // 当前区间的起始值 \u0026gt; 当前合并区间的结束值，说明没有重叠 if (r \u0026lt; intervals[i][0]) { res.push_back({l, r}); // 将当前合并区间加入结果 l = intervals[i][0]; // 更新新的合并区间的起始值 r = intervals[i][1]; // 更新新的合并区间的结束值 } else { // 如果有重叠，则更新当前合并区间的结束值 r = max(r, intervals[i][1]); } } // 将最后一个合并区间加入结果 res.push_back({l, r}); return res; } }; ","date":"2024-11-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/mergeintervals/","title":"mergeIntervals"},{"content":"152. maxProduct 分析 使用f[i - 1]记录所有以nums[i - 1]元素结尾的连续子数组中的最大乘积\n使用g[i - 1]记录所有以nums[i - 1]元素结尾的连续子数组中的最小乘积\n求f[i]\n当nums[i]为正数时，f[i] = std::max(nums[i], f[i - 1] * nums[i])，因为正数与最大值相乘，值最大，所以与f[i - 1]相乘 当nums[i]为负数时，f[i] = std::max(nums[i], g[i - 1] * nums[i])，因为负数与最小值相乘，值最大，所以与g[i - 1]相乘 求g[i]\n当nums[i]为正数时，g[i] = std::min(nums[i], g[i - 1] * nums[i])，因为正数与最小值相乘，值最小，所以与g[i - 1]相乘 当nums[i]为负数时，g[i] = std::min(nums[i], f[i - 1] * nums[i])，因为负数与最大值相乘，值最小，所以与f[i - 1]相乘 当nums[i]为0时，f[i]和g[i]都变为0，即连续子数组断开，从下一个元素重新开始找最大乘积\n优化：因为每次更新f[i]和g[i]只需要前一个数，所以不需要开两个数组记录所有值\n时间复杂度：O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; int f_last = nums[0], g_last = nums[0]; for (int i = 1; i \u0026lt; nums.size(); ++ i) { int f_cur = f_last * nums[i], g_cur = g_last * nums[i]; f_last = std::max(nums[i], std::max(f_cur, g_cur)); g_last = std::min(nums[i], std::min(f_cur, g_cur)); res = std::max(res, f_last); } return res; } }; ","date":"2024-11-23T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxproduct/","title":"maxProduct"},{"content":"190. reverseBits 分析 核心步骤：取二进制数的第i位n \u0026gt;\u0026gt; i \u0026amp; 1\nres每次左移一位，然后将n的最低位加到res上\nC++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t res = 0; for (int i = 0; i \u0026lt; 32; ++ i) res = (res \u0026lt;\u0026lt; 1) + (n \u0026gt;\u0026gt; i \u0026amp; 1); return res; } }; ","date":"2024-11-23T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reversebits/","title":"reverseBits"},{"content":"15. 三数之和 分析 排序数组： 首先将数组从小到大排序，方便后续操作 固定一个数，双指针搜索： 遍历排序后的数组，用 i 指向当前固定的数 在 i 的右侧，使用双指针 j 和 k： j 指向 i + 1 k 指向数组末尾 检查三数之和： 若三数之和小于 0，说明需要更大的值，移动 j 向右 若三数之和大于 0，说明需要更小的值，移动 k 向左 若三数之和等于 0，记录结果，同时移动 j 和 k 跳过重复值 去重： 对于固定数 nums[i]，若 nums[i] = nums[i-1]，跳过当前遍历，避免重复三元组 对于 nums[j] 和 nums[k]，在找到一个解后，继续移动跳过相同值 时间复杂度 排序复杂度：O(nlogn) 三重循环复杂度：外层循环 O(n)，内层双指针 O(n)，总复杂度为 O(n^2) 总时间复杂度 O(n^2)\n空间复杂度 使用排序 O(logn) 的额外空间，其余操作在原地完成，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; std::sort(nums.begin(), nums.end()); // 对数组进行排序 for (int i = 0; i \u0026lt; nums.size(); ++i) { // 跳过重复的固定数 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; // 双指针寻找其他两数 for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; ++ j) { // 跳过重复的第二个数 if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; // 移动右指针，寻找满足条件的三元组 while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) -- k; // 判断当前三数之和是否为零 if (nums[i] + nums[j] + nums[k] == 0) res.push_back({nums[i], nums[j], nums[k]}); } } return res; } }; ","date":"2024-11-22T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/threesum/","title":"threeSum"},{"content":"1. 两数之和 分析 利用哈希表存储数组元素及其下标： 使用一个哈希表，键为数组元素值，值为对应的下标 哈希表可以快速查询某个元素是否已经出现过 遍历数组，寻找目标值对应的数： 在遍历数组时，对于当前元素 nums[i]，计算另一个需要的数 x = target - nums[i]； 在哈希表中检查是否存在 x： 如果 x 存在，说明找到了两个数，返回它们的下标 如果 x 不存在，将当前数 nums[i] 及其索引存入哈希表，继续遍历 时间复杂度 哈希表查询和插入：每次操作 O(1) 数组遍历：遍历一次数组，时间复杂度为 O(n) 总时间复杂度 O(n)\n空间复杂度 需要一个哈希表存储数组中的元素及其索引，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map\u0026lt;int, int\u0026gt; hash; // 哈希表存储元素值及其索引 for (int i = 0; i \u0026lt; nums.size(); ++ i) { int x = target - nums[i]; // 计算需要的数 // 检查是否在哈希表中 if (hash.count(x)) return {hash[x], i}; // 找到目标值，返回下标 // 将当前数存入哈希表 hash[nums[i]] = i; } return {}; // 如果无解，返回空数组（题目保证一定有解） } }; ","date":"2024-11-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/twosum/","title":"twoSum"},{"content":"33. Search in Rotated Sorted Array 分析 首先确定旋转数组后的分段情况，通过二分查找找到数组中旋转点的位置，即最大的元素所在的位置 根据旋转点的位置，将数组分为两段，根据 target 所在的段，重新调整指针 l 和 r 的位置 对 target 所在的段进行二分查找。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.empty()) return -1; int l = 0, r = nums.size() - 1; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= nums[0]) l = mid; else r = mid - 1; } if (target \u0026gt;= nums[0]) l = 0; else l = r + 1, r = nums.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) r = mid; else l = mid + 1; } if (nums[r] == target) return r; return -1; } }; ","date":"2024-04-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/search-in-rotated-sorted-array/","title":"Search in Rotated Sorted Array"},{"content":"32. Longest Valid Parentheses 分析 合法的括号序列一定满足： 前缀序列中，左括号数量 大于等于 右括号数量 左右括号数量相等 分段处理 对于序列中某个右括号的位置，如果满足当前位置是第一次右括号数大于左括号数的位置，那么该右括号位置就为一段的结尾。然后在每一段的内部更新最大合法序列长度。\n证明：任何一个合法括号序列都不会跨越两段 假设一个合法序列 s 跨越了两段 a 和 b。由于是合法序列，所以满足任意一个前缀序列中，左括号数量大于等于右括号数量。那么 s 对应 a 的前半段一定是左括号数量大于右括号数量的，而划分每一段时，结尾位置都是第一次右括号数大于左括号数的位置，而现在 s 对应的这段是左括号数大于右括号数。那么，a 去掉 s 对应的那段的剩余前半段一定是右括号数大于左括号数的，那 a 的结尾位置就不是第一次右括号数大于左括号数的位置，出现矛盾。\n每段内部找合法序列 由于右边界位置是第一次右括号数大于左括号数的位置，所以它前面的每一个右括号都一定能找到对应的左括号。因此，只要枚举以每个右括号为右端点的最长的一个合法括号序列的左端点是什么位置。\n对于每个右括号，找到最靠左的左括号位置可以用栈来做。\n从每一段起始位置开始，记录一下其实位置start，如果是左括号，就把它的下标入栈 否则（说明是右括号） 判断栈是否为空 不为空，出栈一个左括号 判断栈是否为空 不为空，则以当前右括号为右端点的合法区间的最靠左元素就是栈顶元素的下一个位置。它的长度是 i - 栈顶元素 为空，说明当前右括号的最靠左元素可以到起点位置。长度就是i - start 为空，说明对于当前右括号，左括号已经没有了，也就是第一个右括号数大于左括号的位置，这一段结束，更新下段起始位置start = i C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int longestValidParentheses(string s) { stack\u0026lt;int\u0026gt; stk; int res = 0; for (int i = 0, start = -1; i \u0026lt; s.size(); i ++ ) { if (s[i] == \u0026#39;(\u0026#39;) stk.push(i); else { if (stk.size()) { stk.pop(); if (stk.size()) res = max(res, i - stk.top()); else res = max(res, i - start); } else { start = i; } } } return res; } }; ","date":"2024-04-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-valid-parentheses/","title":"Longest Valid Parentheses"},{"content":"31. Next Permutation 分析 首先，找到排列中从右往左第一个非递增的数字，记其索引为 k。 如果 k 为 0 或者更小，则说明当前排列已经是最大的排列，因此直接将整个排列反转即可得到最小的排列。 否则，从索引 k 开始往右查找，找到比索引 k-1 处元素大的最小元素，并将其与索引 k-1 处的元素交换。 最后，将索引 k 右侧的元素逆序排列，以确保得到的排列是比原排列大的下一个字典序排列。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int k = nums.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k - 1] \u0026gt;= nums[k]) k -- ; if (k \u0026lt;= 0) reverse(nums.begin(), nums.end()); else { int t = k; while (t \u0026lt; nums.size() \u0026amp;\u0026amp; nums[t] \u0026gt; nums[k - 1]) t ++ ; swap(nums[k - 1], nums[t - 1]); reverse(nums.begin() + k, nums.end()); } } }; ","date":"2024-04-01T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/next-permutation/","title":"Next Permutation"},{"content":"29. Divide Two Integers 分析 用位运算模拟除法过程\n例如，对于$\\frac{x}{y}=k$， 将k转换成2进制的形式，有$k = 2^{0} + 2^{1} + \u0026hellip; + 2^{31}$\n我们可以将每一位的值存下来，然后从高位向低位遍历，只要 x 大于当前位的值，x 就减去当前位的值\n又因为$x=yk=y2^0+y2^1+\u0026hellip;+y2^{31}$，所以每次 x 减去第i位的值时，最终要求得的商就加上 $2^{i}$\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int divide(int dividend, int divisor) { typedef long long LL; vector\u0026lt;LL\u0026gt; exp; bool is_minus = false; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) is_minus = true; LL a = abs((LL)dividend), b = abs((LL)divisor); for (LL i = b; i \u0026lt;= a; i = i + i) exp.push_back(i); LL res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i -- ) { if (a \u0026gt;= exp[i]) { a -= exp[i]; res += (LL)1 \u0026lt;\u0026lt; i; } } if (is_minus) res = -res; if (res \u0026gt; INT_MAX) res = INT_MAX; if (res \u0026lt; INT_MIN) res = INT_MIN; return res; } }; ","date":"2024-03-30T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/divide-two-integers/","title":"Divide Two Integers"},{"content":"28. Find the Index of the First Occurrence in a String 分析 在源传和目标串首部添加一个字符，使得下标匹配从1开始，方便处理。 构建目标串的 next 数组。具体来说，对于目标串的任意位置 i，我们要找到一个数 j，使得 needle[1:j] 和 needle[i-j+1:i] 是相等的，并且 j 的值尽可能大。每个 next[i] 对应一个 j 。 遍历源串，在匹配过程中，若 haystack[i] 与 needle[j+1] 不相等，则将 j 回溯到 next[j]。若相等，则同时向后移动 i 和 j。若 j 移动到 needle 的末尾，则表示在 haystack 中找到了 needle，返回 i - m 即可。 时间复杂度为 O(n+m)，其中 n 和 m 分别是 haystack 和 needle 的长度。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; int n = haystack.size(), m = needle.size(); haystack = \u0026#39; \u0026#39; + haystack, needle = \u0026#39; \u0026#39; + needle; vector\u0026lt;int\u0026gt; next(m + 1); for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; needle[i] != needle[j + 1]) j = next[j]; if (needle[i] == needle[j + 1]) j ++ ; next[i] = j; } for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; haystack[i] != needle[j + 1]) j = next[j]; if (haystack[i] == needle[j + 1]) j ++ ; if (j == m) return i - m; } return -1; } }; ","date":"2024-03-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/find-the-index-of-the-first-occurrence-in-a-string/","title":"Find the Index of the First Occurrence in a String"},{"content":"27. Remove Element C++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int k = 0; for (int i = 0; i \u0026lt; nums.size(); i ++ ) if (nums[i] != val) nums[k ++ ] = nums[i]; return k; } }; ","date":"2024-03-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-element/","title":"Remove Element"},{"content":"26. Remove Duplicates from Sorted Array 分析 用索引 k 记录非重复元素的位置。 判断当前元素 i 是否为第一个元素 或 是否与前一个元素不等。 如果满足上述条件，将当前元素复制到数组中索引为 k 的位置，然后递增 k。 最后返回索引 k，它表示移除重复元素后的数组长度。 C++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int k = 0; for (int i = 0; i \u0026lt; nums.size(); i ++ ) if (!i || nums[i] != nums[i - 1]) nums[k ++ ] = nums[i]; return k; } }; ","date":"2024-03-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-duplicates-from-sorted-array/","title":"Remove Duplicates from Sorted Array"},{"content":"25. Reverse Nodes in k-Group 分析 每k个节点为一段，每次循环先找到当前段的尾节点 q，如果 q 为 NULL，说明当前段不够k个节点，跳出循环。\n若q不为空，则对当前段进行反转。先反转段内的节点，定义两个指针 a 和 b 分别指向当前段的首节点和第二个节点。在每次循环中，将当前节点 b 的 next 指针指向前一个节点 a，然后更新 a 和 b。\n反转完成后，将当前段的首节点 p-\u0026gt;next 指向反转后的首节点 a，将原始的首节点 c 的 next 指针指向当前段的下一个节点 b。\n将指针 p 移动到下一个要反转的段的首节点处，即 p = c。\n时间复杂度为 O(N)，其中 N 是链表的长度，因为只需一次遍历即可完成每 k 个节点的反转。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; for (ListNode *p = dummy; ;) { ListNode *q = p; for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; q; i ++ ) q = q-\u0026gt;next; if (!q) break; ListNode *a = p-\u0026gt;next, *b = a-\u0026gt;next; for (int i = 0; i \u0026lt; k - 1; i ++ ) { ListNode *c = b-\u0026gt;next; b-\u0026gt;next = a; a = b, b = c; } ListNode *c = p-\u0026gt;next; p-\u0026gt;next = a; c-\u0026gt;next = b; p = c; } return dummy-\u0026gt;next; } }; ","date":"2024-03-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reverse-nodes-in-k-group/","title":"Reverse Nodes in k-Group"},{"content":"24. Swap Nodes in Pairs C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; for (ListNode* p = dummy; p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;next; ) { ListNode* a = p-\u0026gt;next; ListNode* b = a-\u0026gt;next; p-\u0026gt;next = b; a-\u0026gt;next = b-\u0026gt;next; b-\u0026gt;next = a; p = a; } return dummy-\u0026gt;next; } }; ","date":"2024-03-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/swap-nodes-in-pairs/","title":"Swap Nodes in Pairs"},{"content":"23. Merge k Sorted Lists 分析 用优先队列来维护当前 k 个链表中最小的元素。\n时间复杂度为 O(Nlogk)，其中 N 是所有链表节点的总数，k 是链表的数量，每次插入和删除操作的时间复杂度为 O(logk)，总共需要执行 N 次插入和删除操作。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct Cmp { bool operator() (ListNode* a, ListNode* b) { return a-\u0026gt;val \u0026gt; b-\u0026gt;val; } }; ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, Cmp\u0026gt; heap; ListNode *dummy = new ListNode(-1), *tail = dummy; for (ListNode* p: lists) if (p) heap.push(p); while (heap.size()) { ListNode* t = heap.top(); heap.pop(); tail = tail-\u0026gt;next = t; if (t-\u0026gt;next) heap.push(t-\u0026gt;next); } return dummy-\u0026gt;next; } }; ","date":"2024-03-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-k-sorted-lists/","title":"Merge k Sorted Lists"},{"content":"22. Generate Parentheses 分析 一个合法括号系列（只有一种括号时）的充分必要条件是：\n任意前缀序列中左括号数量大于等于右括号数量 左右括号数量相等 这里的左右括号数量一定是相等的，所以只要满足第一个条件就行了。\n如果不需要输出所有方案，只要方案数量的话，那就可以直接用公式 $\\frac{C_{2n}^{n}}{n+1}$ 求。\n假设当前位置为i，则该位置要么是左括号，要么是右括号。\n当0～i-1中的左括号数量小于n时，则位置i可以为左括号，否则不可以。 当0～i-1中的右括号数量小于n时，且前缀序列中左括号数量大于右括号数量，则位置i可以为右括号，否则不可以。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0, \u0026#34;\u0026#34;); return res; } void dfs(int n, int lc, int rc, string seq) { if (lc == n \u0026amp;\u0026amp; rc == n) res.push_back(seq); else { if (lc \u0026lt; n) dfs(n, lc + 1, rc, seq + \u0026#39;(\u0026#39;); if (rc \u0026lt; n \u0026amp;\u0026amp; rc \u0026lt; lc) dfs(n, lc, rc + 1, seq + \u0026#39;)\u0026#39;); } } }; ","date":"2024-03-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/generate-parentheses/","title":"Generate Parentheses"},{"content":"21. Merge Two Sorted Lists 分析 经典的二路归并算法，每次把两个链表中的较小值加入到新链表中。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode *dummy = new ListNode(-1); ListNode *cur = dummy; while (list1 \u0026amp;\u0026amp; list2) { if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val) { cur = cur-\u0026gt;next = list1; list1 = list1-\u0026gt;next; } else { cur = cur-\u0026gt;next = list2; list2 = list2-\u0026gt;next; } } if (list1) cur-\u0026gt;next = list1; if (list2) cur-\u0026gt;next = list2; return dummy-\u0026gt;next; } }; ","date":"2024-03-22T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-two-sorted-lists/","title":"Merge Two Sorted Lists"},{"content":"19. Remove Nth Node From End of List 分析 因为被删的可能是头节点，先建个虚拟头节点。\n要删除倒数第k个点，只要找到倒数第k+1个点的位置，将其指针指向k的next。\n因此先遍历一遍链表，得到链表长度。在遍历一次找到倒数第k+1个点。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; int len = 0; for (ListNode* p = dummy; p; p = p-\u0026gt;next) len ++ ; ListNode* p = dummy; for (int i = 0; i \u0026lt; len - n - 1; i ++ ) p = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-nth-node-from-end-of-list/","title":"Remove Nth Node From End of List"},{"content":"20. Valid Parentheses 分析 每次遇到一个左括号就加到栈里，每遇到一个右括号就和栈顶元素进行匹配。如果匹配，栈顶元素出栈，不匹配则不合法。最后判断下栈是否为空，为空则合法，否则不合法。\n一个小技巧是根据根据ASCII码来判断括号是否匹配，\u0026rsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 的值相差1，\u0026rsquo;[\u0026rsquo; 和 \u0026lsquo;]\u0026rsquo; 、 \u0026lsquo;{\u0026rsquo; 和 \u0026lsquo;}\u0026rsquo; 的值相差2。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: bool isValid(string s) { stack\u0026lt;char\u0026gt; stk; for (char c: s) { if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) stk.push(c); else { if (stk.size() \u0026amp;\u0026amp; abs(stk.top() - c) \u0026lt;= 2) stk.pop(); else return false; } } return stk.empty(); } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/valid-parentheses/","title":"Valid Parentheses"},{"content":"18. 4Sum 分析 与三数之和一样，只是这里要枚举两个位置 i 和 j。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: typedef long long LL; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); j ++ ) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; for (int k = j + 1, l = nums.size() - 1; k \u0026lt; l; k ++ ) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) continue; while (l - 1 \u0026gt; k \u0026amp;\u0026amp; (LL)nums[i] + nums[j] + nums[k] + nums[l - 1] \u0026gt;= target) l -- ; if ((LL)nums[i] + nums[j] + nums[k] + nums[l] == (LL)target) { res.push_back({nums[i], nums[j], nums[k], nums[l]}); } } } } return res; } }; ","date":"2024-03-20T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/4sum/","title":"4Sum"},{"content":"17. Letter Combinations of a Phone Number 分析 经典的DFS问题，画个递归树，把过程转换成代码。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;string\u0026gt; res; string str[10] = { \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34; }; vector\u0026lt;string\u0026gt; letterCombinations(string digits) { if (digits.empty()) return res; dfs(digits, 0, \u0026#34;\u0026#34;); return res; } void dfs(string digits, int u, string path) { if (u == digits.size()) res.push_back(path); else { for (auto c: str[digits[u] - \u0026#39;0\u0026#39;]) dfs(digits, u + 1, path + c); } } }; ","date":"2024-03-19T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/letter-combinations-of-a-phone-number/","title":"Letter Combinations of a Phone Number"},{"content":"16. 3Sum Closest 分析 暴力做法就是三重循环，每种答案枚举一遍，求一个最接近的值。\n用双指针优化。先枚举位置i，对每一个位置j，找到一个最小的位置k使得 nums[i] + nums[j] + nums[k] \u0026gt;= target，这样可以得到大于等于target的最小值。并且，当k满足前述条件时，必然有 nums[i] + nums[j] + nums[k - 1] \u0026lt; target，也就可以得到小于target的最大值。每次更新下这两个值即可。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(), nums.end()); pair\u0026lt;int, int\u0026gt; res(INT_MAX, INT_MAX); for (int i = 0; i \u0026lt; nums.size(); i ++ ) for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++ ) { while (k - 1 \u0026gt; j \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) k -- ; int s = nums[i] + nums[j] + nums[k]; res = min(res, make_pair(abs(s - target), s)); if (k - 1 \u0026gt; j) { s = nums[i] + nums[j] + nums[k - 1]; res = min(res, make_pair(target - s, s)); } } return res.second; } }; ","date":"2024-03-18T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/3sum-closest/","title":"3Sum Closest"},{"content":"14. Longest Common Prefix 分析 首先看所有字符串第一个字符是否一样，一样则公共字符串长度至少为1，否则公共字符串为空。 再看第二个字符是否一样，这样一直遍历下去\u0026hellip; 最坏情况就是把所有字符串的每个字符枚举一遍，时间复杂度小于等于所有字符串之和。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (i \u0026gt;= str.size() || str[i] != c) return res; res += c; } return res; } }; ","date":"2024-03-16T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-common-prefix/","title":"Longest Common Prefix"},{"content":"13. Roman to Integer 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 可以发现，除了4、9、40、90、400、900以外，其他的数字都可以通过加法得到。例如，80是LXXX，其中L是50，X是10，也就是 50 + 10 + 10 + 10 = 80。同理，300是CCC，C是100，所以有 100 + 100 + 100 = 300。\n而4、9、40、90、400、900可以通过减法得到。它们对应的罗马数字，前一个字符的数值都要比后一个字符数值小，并且改罗马数字的值等于后一个字符的数值减去前一个字符的数值。例如，40是XL，X是10，L是50，也就是 50 - 10 = 40。\n因此，只要每次看当前字符是否比后一个字符小，是的话就减去字符的值，否则就加上字符的值。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int romanToInt(string s) { unordered_map\u0026lt;char, int\u0026gt; hash; hash[\u0026#39;I\u0026#39;] = 1; hash[\u0026#39;V\u0026#39;] = 5; hash[\u0026#39;X\u0026#39;] = 10; hash[\u0026#39;L\u0026#39;] = 50; hash[\u0026#39;C\u0026#39;] = 100; hash[\u0026#39;D\u0026#39;] = 500; hash[\u0026#39;M\u0026#39;] = 1000; int res = 0; for (int i = 0; i \u0026lt; s.size(); i ++ ) { if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) res -= hash[s[i]]; else res += hash[s[i]]; } return res; } }; ","date":"2024-03-15T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/roman-to-integer/","title":"Roman to Integer"},{"content":"12. Integer to Roman 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 1234 转换成罗马数字是 MCCXXXIV，也就是从千位到个位依次拼接，用代码将过程模拟出来即可。\n但是，可以找下规律。\n千位是1000～3000，把1000的M记下即可，只要当前数大于1000，就减去1000，换成一个M。\n百位的100～300记下C，每减100就换一个C。400无规律，单独记下CD。同理，500～800记下D，900记下CM。\n十位记下10、40、50、90，也就是X、XL、L、XC。个位记下1、4、5、9，也就是I、IV、V、IX。\n然后对记下的这些数字，从大到小去考虑。例如大于900，当前值减去900，字符串拼接一个CM。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: string intToRoman(int num) { int values[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string romans[] = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; string res; for (int i = 0; i \u0026lt;= 12; i ++ ) { while (num \u0026gt;= values[i]) { res += romans[i]; num -= values[i]; } } return res; } }; ","date":"2024-03-14T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/integer-to-roman/","title":"Integer to Roman"},{"content":"11. Container With Most Water 分析 用两个指针i和j分别指向开头和结尾，如果指针i指向的水柱高度较低，则指针i向后移，反之指针j向前移。每移动一次后，求当前指针i和j指向水柱之间的面积，更新一下最大值。\n为什么更新出来的值一定是最优解。 i和j最开始在两侧，每次把一个指针向中间靠拢，则一定有一侧指针会先到最优解的位置。假定指针i先到最优解位置，则指针j一定在其最优解位置的右边，并且指针j在到达最优解位置前每次指向的水柱高度严格小于最优解位置的高度。\n可以使用反证法证明。如果指针j当前指向的水柱高度大于等于其最优解位置的高度，则能装的水量一定大于最优解，就和最优解位置矛盾。因此，通过上述过程，一定可以遍历出最优解。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = 0; for (int i = 0, j = height.size() - 1; i \u0026lt; j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) i ++ ; else j -- ; } return res; } }; ","date":"2024-03-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/container-with-most-water/","title":"Container With Most Water"},{"content":"Similar Vocabulary high \u0026amp; tall high for things that are wider than their vertical height Sherlock Holmes fell from the top of a high building. I put the books on a high shelf. tall for things that are narrower than their vertical height Burj Khalifa is the tallest building in the world. My brother is six foot tall. big \u0026amp; large big for real and abstract things big city big house big decision big ideas large for real things with a more formal tone a large population a large number of projects a large amount of money Comparatives and Superlatives adjectives Comparatives Comparative adjectives tell us how something is different (the original smaller home of the BBC) or how something has changed (It\u0026rsquo;s busier than ever).\nHow do we form comparative adjectives?\nIn most cases, we add –er to the adjective to form a comparative (large - larger, fast - faster). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled when –er is added (big - bigger, fat - fatter). If the adjective ends with a consonant + y, we change the y to an i (busy - busier, funny - funnier). use ‘than’ to make a direct comparison with something else (I am taller than my brother.) Superlatives Superlative adjectives highlight something that is bigger, better or more than everything else (the largest live newsroom in Europe, the latest technology).\n** How do we form superlative adjectives?**\nwe add –est after the adjective. We also use ‘the’ before the adjective (fast - the fastest, large - the largest). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled (big - the biggest, fat - the fattest). If the adjective ends with a consonant + y, we change the y to an i (busy - the busiest, funny - the funniest). irregular forms adjective comparative superlative good etter (than) (the) best well better (than) (the) best bad worse (than) (the) worst ill worse (than) (the) worst far further (than) (the) furthest Much and more The comparatives and superlatives are different in these sentences. We use ‘more’ before the adjective to make a comparative form and ‘the most’ to make a superlative. because these adjectives have 2 syllables or more and they don’t end in ‘y’:\nThe new Broadcasting House was the most expensive project in BBC history. Having one central location makes the BBC more efficient. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. The new studios are more comfortable than the old ones. When we make comparisons, we sometimes also use ‘much’ or ‘a lot’ before the adjective for emphasis:\nThe new building is much nicer than the old one. I love this new furniture. It is a lot more comfortable than the old stuff. Our studios are much more modern now. My office is a lot bigger than before. It’s great! We do not use ‘much’ or ‘a lot’ with superlatives because they do not need extra emphasis! Comparing nouns When sentences compare nouns, not adjectives. We use ‘more than’ with a noun to mean ‘a greater number than’ and ‘the most’ with a noun to mean ‘the greatest number’.\nThe BBC reaches a worldwide audience of more than 150 million every week. New Broadcasting House has more departments than the old building. BBC One has the most viewers in the UK. We can use much and many for emphasis. And much more before an uncountable noun (like chocolate or money) and many more before a countable noun (like friends or countries).\nI feel sick. I ate much more chocolate than you. I have many more friends in my hometown than I do here. other forms of comparatives and superlatives one of the most \u0026hellip; Broadcasting House is one of the most iconic buildings in London. The BBC news team is one of the fastest in the world. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. \u0026hellip; as adjective as.. use the structure as + adjective + as to describe two things that are the same in some way.\nI am 3 years older than my brother but he is as tall as me. We are both 1m80 tall. Despite many changes over the years, the BBC is still as important as ever in the UK and around the world. All (of) the best it contains all the latest technology. == it is the most advanced studio in the world, not one of the most advanced. Broadcasting House contains all of the BBC\u0026rsquo;s most popular services. == All the best programmes are made in its studios. Even better \u0026ldquo;there are even more exciting things to see in the TV studios.\u0026rdquo; In this example, we use even for emphasis. For instance, we might say:\nThe original Broadcasting House was one of the BBC\u0026rsquo;s most important centres, but New Broadcasting House is even more important than before. The Beatles were one of Britain\u0026rsquo;s most famous bands when they played at Broadcasting House in 1963. However, they got even more popular later that year. Not as adjective as Paul McCartney is not as old as my grandfather. (means the grandfather is more older than Paul McCartney) Old Broadcasting House was not as modern as New Broadcasting House. (means New Broadcasting House is newer than the old building) ","date":"2023-09-07T00:00:00Z","image":"https://garfieldzhang.site/english-language.jpeg","permalink":"https://garfieldzhang.site/p/comparative-and-superlative/","title":"Comparative and Superlative"}]