[{"content":"21. Merge Two Sorted Lists 分析 经典的二路归并算法，每次把两个链表中的较小值加入到新链表中。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode *dummy = new ListNode(-1); ListNode *cur = dummy; while (list1 \u0026amp;\u0026amp; list2) { if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val) { cur = cur-\u0026gt;next = list1; list1 = list1-\u0026gt;next; } else { cur = cur-\u0026gt;next = list2; list2 = list2-\u0026gt;next; } } if (list1) cur-\u0026gt;next = list1; if (list2) cur-\u0026gt;next = list2; return dummy-\u0026gt;next; } }; ","date":"2024-03-22T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-two-sorted-lists/","title":"Merge Two Sorted Lists"},{"content":"19. Remove Nth Node From End of List 分析 因为被删的可能是头节点，先建个虚拟头节点。\n要删除倒数第k个点，只要找到倒数第k+1个点的位置，将其指针指向k的next。\n因此先遍历一遍链表，得到链表长度。在遍历一次找到倒数第k+1个点。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; int len = 0; for (ListNode* p = dummy; p; p = p-\u0026gt;next) len ++ ; ListNode* p = dummy; for (int i = 0; i \u0026lt; len - n - 1; i ++ ) p = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-nth-node-from-end-of-list/","title":"Remove Nth Node From End of List"},{"content":"20. Valid Parentheses 分析 每次遇到一个左括号就加到栈里，每遇到一个右括号就和栈顶元素进行匹配。如果匹配，栈顶元素出栈，不匹配则不合法。最后判断下栈是否为空，为空则合法，否则不合法。\n一个小技巧是根据根据ASCII码来判断括号是否匹配，\u0026rsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 的值相差1，\u0026rsquo;[\u0026rsquo; 和 \u0026lsquo;]\u0026rsquo; 、 \u0026lsquo;{\u0026rsquo; 和 \u0026lsquo;}\u0026rsquo; 的值相差2。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: bool isValid(string s) { stack\u0026lt;char\u0026gt; stk; for (char c: s) { if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) stk.push(c); else { if (stk.size() \u0026amp;\u0026amp; abs(stk.top() - c) \u0026lt;= 2) stk.pop(); else return false; } } return stk.empty(); } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/valid-parentheses/","title":"Valid Parentheses"},{"content":"18. 4Sum 分析 与三数之和一样，只是这里要枚举两个位置 i 和 j。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: typedef long long LL; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); j ++ ) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; for (int k = j + 1, l = nums.size() - 1; k \u0026lt; l; k ++ ) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) continue; while (l - 1 \u0026gt; k \u0026amp;\u0026amp; (LL)nums[i] + nums[j] + nums[k] + nums[l - 1] \u0026gt;= target) l -- ; if ((LL)nums[i] + nums[j] + nums[k] + nums[l] == (LL)target) { res.push_back({nums[i], nums[j], nums[k], nums[l]}); } } } } return res; } }; ","date":"2024-03-20T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/4sum/","title":"4Sum"},{"content":"17. Letter Combinations of a Phone Number 分析 经典的DFS问题，画个递归树，把过程转换成代码。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;string\u0026gt; res; string str[10] = { \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34; }; vector\u0026lt;string\u0026gt; letterCombinations(string digits) { if (digits.empty()) return res; dfs(digits, 0, \u0026#34;\u0026#34;); return res; } void dfs(string digits, int u, string path) { if (u == digits.size()) res.push_back(path); else { for (auto c: str[digits[u] - \u0026#39;0\u0026#39;]) dfs(digits, u + 1, path + c); } } }; ","date":"2024-03-19T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/letter-combinations-of-a-phone-number/","title":"Letter Combinations of a Phone Number"},{"content":"16. 3Sum Closest 分析 暴力做法就是三重循环，每种答案枚举一遍，求一个最接近的值。\n用双指针优化。先枚举位置i，对每一个位置j，找到一个最小的位置k使得 nums[i] + nums[j] + nums[k] \u0026gt;= target，这样可以得到大于等于target的最小值。并且，当k满足前述条件时，必然有 nums[i] + nums[j] + nums[k - 1] \u0026lt; target，也就可以得到小于target的最大值。每次更新下这两个值即可。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(), nums.end()); pair\u0026lt;int, int\u0026gt; res(INT_MAX, INT_MAX); for (int i = 0; i \u0026lt; nums.size(); i ++ ) for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++ ) { while (k - 1 \u0026gt; j \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) k -- ; int s = nums[i] + nums[j] + nums[k]; res = min(res, make_pair(abs(s - target), s)); if (k - 1 \u0026gt; j) { s = nums[i] + nums[j] + nums[k - 1]; res = min(res, make_pair(target - s, s)); } } return res.second; } }; ","date":"2024-03-18T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/3sum-closest/","title":"3Sum Closest"},{"content":"15. 3Sum 分析 首先将数组排序，每个答案数组包含三个数，而双指针只能处理两个位置，所以先枚举第一个数的位置。为了减少一些重复情况，我们设定 i \u0026lt; j \u0026lt; k。当i固定后，对于当前j，只需要找到最小的k使得 nums[i] + nums[j] + nums[k] \u0026gt;= 0。此时，若 nums[i] + nums[j] + nums[k] = 0， 则为答案数组。否则，由于 nums[i] + nums[j] + nums[k - 1] \u0026lt; 0，k不能再向左移动（递减），需要j向右移动（递增）。\n最后考虑避免重复情况。只需要保证i指向的下一个元素与当前元素不等即可，因为当前元素对应的答案数组已经被考虑过了。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++ ) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) k -- ; if (nums[i] + nums[j] + nums[k] == 0) { res.push_back({nums[i], nums[j], nums[k]}); } } } return res; } }; ","date":"2024-03-17T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/3sum/","title":"3Sum"},{"content":"14. Longest Common Prefix 分析 首先看所有字符串第一个字符是否一样，一样则公共字符串长度至少为1，否则公共字符串为空。 再看第二个字符是否一样，这样一直遍历下去\u0026hellip; 最坏情况就是把所有字符串的每个字符枚举一遍，时间复杂度小于等于所有字符串之和。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (i \u0026gt;= str.size() || str[i] != c) return res; res += c; } return res; } }; ","date":"2024-03-16T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-common-prefix/","title":"Longest Common Prefix"},{"content":"13. Roman to Integer 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 可以发现，除了4、9、40、90、400、900以外，其他的数字都可以通过加法得到。例如，80是LXXX，其中L是50，X是10，也就是 50 + 10 + 10 + 10 = 80。同理，300是CCC，C是100，所以有 100 + 100 + 100 = 300。\n而4、9、40、90、400、900可以通过减法得到。它们对应的罗马数字，前一个字符的数值都要比后一个字符数值小，并且改罗马数字的值等于后一个字符的数值减去前一个字符的数值。例如，40是XL，X是10，L是50，也就是 50 - 10 = 40。\n因此，只要每次看当前字符是否比后一个字符小，是的话就减去字符的值，否则就加上字符的值。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int romanToInt(string s) { unordered_map\u0026lt;char, int\u0026gt; hash; hash[\u0026#39;I\u0026#39;] = 1; hash[\u0026#39;V\u0026#39;] = 5; hash[\u0026#39;X\u0026#39;] = 10; hash[\u0026#39;L\u0026#39;] = 50; hash[\u0026#39;C\u0026#39;] = 100; hash[\u0026#39;D\u0026#39;] = 500; hash[\u0026#39;M\u0026#39;] = 1000; int res = 0; for (int i = 0; i \u0026lt; s.size(); i ++ ) { if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) res -= hash[s[i]]; else res += hash[s[i]]; } return res; } }; ","date":"2024-03-15T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/roman-to-integer/","title":"Roman to Integer"},{"content":"12. Integer to Roman 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 1234 转换成罗马数字是 MCCXXXIV，也就是从千位到个位依次拼接，用代码将过程模拟出来即可。\n但是，可以找下规律。\n千位是1000～3000，把1000的M记下即可，只要当前数大于1000，就减去1000，换成一个M。\n百位的100～300记下C，每减100就换一个C。400无规律，单独记下CD。同理，500～800记下D，900记下CM。\n十位记下10、40、50、90，也就是X、XL、L、XC。个位记下1、4、5、9，也就是I、IV、V、IX。\n然后对记下的这些数字，从大到小去考虑。例如大于900，当前值减去900，字符串拼接一个CM。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: string intToRoman(int num) { int values[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string romans[] = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; string res; for (int i = 0; i \u0026lt;= 12; i ++ ) { while (num \u0026gt;= values[i]) { res += romans[i]; num -= values[i]; } } return res; } }; ","date":"2024-03-14T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/integer-to-roman/","title":"Integer to Roman"},{"content":"11. Container With Most Water 分析 用两个指针i和j分别指向开头和结尾，如果指针i指向的水柱高度较低，则指针i向后移，反之指针j向前移。每移动一次后，求当前指针i和j指向水柱之间的面积，更新一下最大值。\n为什么更新出来的值一定是最优解。 i和j最开始在两侧，每次把一个指针向中间靠拢，则一定有一侧指针会先到最优解的位置。假定指针i先到最优解位置，则指针j一定在其最优解位置的右边，并且指针j在到达最优解位置前每次指向的水柱高度严格小于最优解位置的高度。\n可以使用反证法证明。如果指针j当前指向的水柱高度大于等于其最优解位置的高度，则能装的水量一定大于最优解，就和最优解位置矛盾。因此，通过上述过程，一定可以遍历出最优解。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = 0; for (int i = 0, j = height.size() - 1; i \u0026lt; j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) i ++ ; else j -- ; } return res; } }; ","date":"2024-03-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/container-with-most-water/","title":"Container With Most Water"},{"content":"Particle for \u0026ldquo;but/however\u0026rdquo; が - more formal けど - more casual/conversational はれども - formal Using が/けど with two sentences [Sentence 1] + が/けど + [Sentence 2]\n日本語は難しいが、楽しい。 - Japanese is hard but fun. 日本語は難しいけど、楽しい。 but/however Example (Polite) 日本語は難しいですが、楽しいです。 日本語は難しいですけど、楽しいです。 が/けど with noun/na-adjectives we must append だ if the first sentence ends in noun or na-adjective before appending が or けど.\n簡単 【かんたん】 - simple, easy 日本語は簡単だが、楽しい。 日本語は簡単だでど、楽しい。 Which needs だ 大丈夫 【だい じょう ぶ】 - ok(na-adj) 暇 【ひま】 - free(na-adj) 楽しいけど、難しい。 簡単じゃないが、大丈夫。 今日は暇けど、明日は忙しい。 学生ですが、大丈夫ですが？ Particle for \u0026ldquo;because/so\u0026rdquo; から - generic ので - a bit more polite Using から/ので with two sentences [Reason] + から/ので + [Result]\nBecause/so Example 日本語は難しいから、楽しい。 日本語は難しいので、楽しい。 から/ので with noun/na-adjectives if the first sentence ends in noun or na-adjective\nappend だ before から appedn な before ので 日本語は簡単だから、楽しい。 日本語は簡単なので、楽しい。 Particle for \u0026ldquo;in spite of\u0026rdquo; のに Using のに with two sentences [Sentence 1] のに [Sentence 2]\n\u0026ldquo;in spite of\u0026rdquo; Example 日本語は難しいのに、楽しい。 日本語は簡単なのに、楽しい。　簡単(na-adjective) 日本語は簡単なのに。 - Despite Japanese being easy. なのに、楽しい。 - Despite that, it\u0026rsquo;s fun. all conjunctions with noun/adjectives だけど、楽しい。 - however/but (append だ) だが、楽しい。 - however/but (append だ) だから、楽しい。 - because/so (append だ) なので、楽しい。 - because/so (append な) なのに、楽しい。 - in spite of (append な) Not all conjunctions are particles でも - but でも is not a particle and can only be used with one sentence. Conjunction rule summary If the first sentence ends in a noun or na-adjective of the first sentence is omitted.\nUse な if conjunction starts with の (なので, なのに) Otherwise use だ (だけど, だが, だから) Grammar practice Because it\u0026rsquo;s fun.\n楽しいから。 たのしので。 たのしからです。(polite) Even though it\u0026rsquo;s easy?\n簡単なのに？ 簡単なのにですか。(polite) That\u0026rsquo;s why it\u0026rsquo;s fun.\nだから、楽しい。 なので、楽しい。 だから、楽しいです。 なので、楽しいです。 I\u0026rsquo;m free today but not tomorrow.\n今日は暇だけど、明日は暇じゃない。 今日は暇だが、明日は暇じゃない。 今日は暇ですけど、明日は暇じゃないです。 今日は暇ですが、明日は暇じゃないです。 I\u0026rsquo;m not free today but tomorrow is ok.\n今日は暇じゃないけど、明日は大丈夫。 今日は暇じゃないが、明日は大丈夫。 今日は暇じゃないですけど、明日は大丈夫です。 今日は暇じゃないですが、明日は大丈夫です。 Combining two sentences with “but” 今日は忙しいけど、明日は暇。 今日は忙しいですが、明日は暇です。 If the first clause ends with a noun or na-adjective without any tense and you’re not using 「です」, you must add 「だ」.\n今日は暇だけど、明日は忙しい。 今日は暇ですけど、明日は忙しいです。 今日は暇たが、明日は忙しい。 今日は暇ですが、明日は忙しいです。 If the noun or na-adjective is already conjugated （such as the negative 「じゃない」）, you don’t need to add 「だ」.\n今日は暇じゃないけど、明日は暇。 今日は暇じゃないが、明日は暇。 Combining two sentences with “so” ここ - here うるさい - noisy ここは、うるさいから、あまり好きじゃない。 - It\u0026rsquo;s noisy here so I don\u0026rsquo;t like it very much. ここは、うるさいですので、あまり好きじゃないです。 - It\u0026rsquo;s noisy here so I don\u0026rsquo;t like it very much. Once again, If the first clause ends with a noun or na-adjective without anything else （such as 「です」 or 「じゃない」）, you must add 「だ」 for 「から」 and 「な」 for 「ので」.\n静か 【しずか】 - quiet ここは静かだから、好き。 - It\u0026rsquo;s quiet here so I like it. ここは静かですから、好きです。 ここは静かなので、好き。 ここは静かですので、好きです。 If the noun or na-adjective is already conjugated （such as the negative 「じゃない」）, you don’t need to add 「だ」.\nここは静かじゃないから、あまり好きじゃない。 ここは静かじゃないので、あまり好きじゃない。 Combining two sentences with \u0026ldquo;despite\u0026rdquo; とても - very 若い 【わかい】 - young 今年【ことし】 - this year 不景気【ふけいき】 - (economic) recession クリスマス - Christmas あ客さん【あきゃくさん】 - customer 少ない【すくない】 - few, scarce かはいい - cute 真面目【ま じ め】 - serious, diligent 男【おとこ】 - man 友達【とも だち】 - friend 田中さんは、先生なのに、とても若いです。 - Despite the fact that Tanaka-san is (a) teacher, (she) is very young. 今年は、不景気だから、クリスマスなのに、あ客さんが少ない。 - This year is recession so despite it being Christmas, customers are few. アリスは、かわいいのに、真面目だから、男の友達が少ない。 - Although Alice is cute, because (she’s) serious, (she has) few male friends. Leaving parts out You can leave out either side of the conjunction if it’s understood by context.\nスミス：ここは、好きじゃない。 - I don’t like (it) here. リー：なんで？ - Why? スミス：うるさいから。 - Because it’s noisy. If you leave the first part out, you still need to add 「です」, 「だ」, or 「な」 just as if the first sentence was there.\n図書館 【と しょ かん】 - library あまり - not very (when used with negative) リー：図書館なのに、ここはいつもうるさいよね。 - Despite it’s library, It’s always noisy here, huh? スミス：だから、あまり好きじゃない。 - That’s why I don’t like it very much. ですから、あまり好きじゃないです。 なので、あまり好きじゃないです。 You can even leave out both parts of the conjunction as seen in the next dialogue.\n最近 【さい きん】 - recently 大変 【たい へん】 - hard リー：最近は、忙しいよ。 - I’m busy lately, you know? スミス：だから？ - So? だから、大変だよ！だけど今日は、やっと暇だから、うれしい！ - So it’s tough, you know! But I’m finally free today so I’m happy! スミス：あっ、そう？ - Oh, is that so? ","date":"2023-09-11T00:00:00Z","image":"https://garfieldzhang.site/p/conjunctions-in-japanese/reading-katakana_hu49c03114a9ce8ad2bc0bd62c0ddb3f2a_72085_120x120_fill_q75_box_smart1.jpg","permalink":"https://garfieldzhang.site/p/conjunctions-in-japanese/","title":"Conjunctions in Japanese"},{"content":"Similar Vocabulary high \u0026amp; tall high for things that are wider than their vertical height Sherlock Holmes fell from the top of a high building. I put the books on a high shelf. tall for things that are narrower than their vertical height Burj Khalifa is the tallest building in the world. My brother is six foot tall. big \u0026amp; large big for real and abstract things big city big house big decision big ideas large for real things with a more formal tone a large population a large number of projects a large amount of money Comparatives and Superlatives adjectives Comparatives Comparative adjectives tell us how something is different (the original smaller home of the BBC) or how something has changed (It\u0026rsquo;s busier than ever).\nHow do we form comparative adjectives?\nIn most cases, we add –er to the adjective to form a comparative (large - larger, fast - faster). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled when –er is added (big - bigger, fat - fatter). If the adjective ends with a consonant + y, we change the y to an i (busy - busier, funny - funnier). use ‘than’ to make a direct comparison with something else (I am taller than my brother.) Superlatives Superlative adjectives highlight something that is bigger, better or more than everything else (the largest live newsroom in Europe, the latest technology).\n** How do we form superlative adjectives?**\nwe add –est after the adjective. We also use ‘the’ before the adjective (fast - the fastest, large - the largest). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled (big - the biggest, fat - the fattest). If the adjective ends with a consonant + y, we change the y to an i (busy - the busiest, funny - the funniest). irregular forms adjective comparative superlative good etter (than) (the) best well better (than) (the) best bad worse (than) (the) worst ill worse (than) (the) worst far further (than) (the) furthest Much and more The comparatives and superlatives are different in these sentences. We use ‘more’ before the adjective to make a comparative form and ‘the most’ to make a superlative. because these adjectives have 2 syllables or more and they don’t end in ‘y’:\nThe new Broadcasting House was the most expensive project in BBC history. Having one central location makes the BBC more efficient. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. The new studios are more comfortable than the old ones. When we make comparisons, we sometimes also use ‘much’ or ‘a lot’ before the adjective for emphasis:\nThe new building is much nicer than the old one. I love this new furniture. It is a lot more comfortable than the old stuff. Our studios are much more modern now. My office is a lot bigger than before. It’s great! We do not use ‘much’ or ‘a lot’ with superlatives because they do not need extra emphasis! Comparing nouns When sentences compare nouns, not adjectives. We use ‘more than’ with a noun to mean ‘a greater number than’ and ‘the most’ with a noun to mean ‘the greatest number’.\nThe BBC reaches a worldwide audience of more than 150 million every week. New Broadcasting House has more departments than the old building. BBC One has the most viewers in the UK. We can use much and many for emphasis. And much more before an uncountable noun (like chocolate or money) and many more before a countable noun (like friends or countries).\nI feel sick. I ate much more chocolate than you. I have many more friends in my hometown than I do here. other forms of comparatives and superlatives one of the most \u0026hellip; Broadcasting House is one of the most iconic buildings in London. The BBC news team is one of the fastest in the world. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. \u0026hellip; as adjective as.. use the structure as + adjective + as to describe two things that are the same in some way.\nI am 3 years older than my brother but he is as tall as me. We are both 1m80 tall. Despite many changes over the years, the BBC is still as important as ever in the UK and around the world. All (of) the best it contains all the latest technology. == it is the most advanced studio in the world, not one of the most advanced. Broadcasting House contains all of the BBC\u0026rsquo;s most popular services. == All the best programmes are made in its studios. Even better \u0026ldquo;there are even more exciting things to see in the TV studios.\u0026rdquo; In this example, we use even for emphasis. For instance, we might say:\nThe original Broadcasting House was one of the BBC\u0026rsquo;s most important centres, but New Broadcasting House is even more important than before. The Beatles were one of Britain\u0026rsquo;s most famous bands when they played at Broadcasting House in 1963. However, they got even more popular later that year. Not as adjective as Paul McCartney is not as old as my grandfather. (means the grandfather is more older than Paul McCartney) Old Broadcasting House was not as modern as New Broadcasting House. (means New Broadcasting House is newer than the old building) ","date":"2023-09-07T00:00:00Z","image":"https://garfieldzhang.site/p/comparative-and-superlative/english-language_hu0013e2059280eb2f024dab7d361d15b7_248205_120x120_fill_q75_box_smart1.jpeg","permalink":"https://garfieldzhang.site/p/comparative-and-superlative/","title":"Comparative and Superlative"}]