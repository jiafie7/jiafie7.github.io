[{"content":"72. 编辑距离 分析 状态定义\n设 f[i][j] 表示将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数。 状态转移\n如果 word1[i] == word2[j]：不需要额外操作，状态继承自子问题：f[i][j] = f[i-1][j-1] 如果 word1[i] != word2[j]：需要进行操作，从以下三种操作中选择代价最小的一种：f[i][j] = min(f[i-1][j-1] + 1, f[i-1][j] + 1, f[i][j-1] + 1) 替换：f[i-1][j-1] + 1 删除：f[i-1][j] + 1 插入：f[i][j-1] + 1 边界条件\nf[i][0] = i: 将 word1 的前 i 个字符转换为空字符串，需要删除 i 次 f[0][j] = j: 将空字符串转换为 word2 的前 j 个字符，需要插入 j 次 初始化输入：\n在代码中通过向 word1 和 word2 开头添加空格，统一了状态的表示 最终结果：\n返回 f[n][m]，其中 n 是 word1 的长度， m 是 word2 的长度 时间复杂度 外层循环遍历 n，内层循环遍历 m，总时间复杂度为 O(nm)\n空间复杂度 空间复杂度为 O(nm)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int minDistance(string word1, string word2) { // 在字符串开头添加空格，便于边界处理 word1 = \u0026#34; \u0026#34; + word1; word2 = \u0026#34; \u0026#34; + word2; int n = word1.size(), m = word2.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n, std::vector\u0026lt;int\u0026gt;(m)); // 初始化边界条件 for (int i = 0; i \u0026lt; n; ++i) f[i][0] = i; for (int j = 0; j \u0026lt; m; ++j) f[0][j] = j; for (int i = 1; i \u0026lt; n; ++i) for (int j = 1; j \u0026lt; m; ++j) { // 删除、插入、替换操作的最优选择 f[i][j] = std::min(f[i - 1][j] + 1, f[i][j - 1] + 1); if (word1[i] == word2[j]) f[i][j] = std::min(f[i][j], f[i - 1][j - 1]); else f[i][j] = std::min(f[i][j], f[i - 1][j - 1] + 1); } // 返回结果 return f[n - 1][m - 1]; } }; ","date":"2024-12-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/edit-distance/","title":"Edit Distance"},{"content":"1143. 最长公共子序列 分析 定义状态：\nf[i][j] 表示字符串 text1 的前 i 个字符与 text2 的前 j 个字符的最长公共子序列的长度 状态转移：\n当 text1[i-1] == text2[j-1]，当前字符匹配，可以延续公共子序列的长度：f[i][j] = f[i-1][j-1] + 1\n当 text1[i-1] != text2[j-1]，当前字符不匹配，最长公共子序列取决于舍弃其中一个字符的结果：f[i][j] = \\max(f[i-1][j], f[i][j-1])\n边界条件：\nf[i][0] = 0 和 f[0][j] = 0，表示任意一个字符串与空字符串的最长公共子序列长度为 0 结果：\n最终结果存储在 f[n][m]，其中 n 和 m 分别是 text1 和 text2 的长度 时间复杂度 外层循环遍历 n，内层循环遍历 m ，时间复杂度为 O(nm)\n空间复杂度 空间复杂度为 O(nm)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int longestCommonSubsequence(string text1, string text2) { int n = text1.size(), m = text2.size(); std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n + 1, std::vector\u0026lt;int\u0026gt;(m + 1)); // 遍历每个字符的组合 for (int i = 1; i \u0026lt;= n; ++i) for (int j = 1; j \u0026lt;= m; ++j) { f[i][j] = std::max(f[i][j - 1], f[i - 1][j]); // 两个字符匹配时 if (text1[i - 1] == text2[j - 1]) f[i][j] = std::max(f[i][j], f[i - 1][j - 1] + 1); } // 返回最终结果 return f[n][m]; } }; ","date":"2024-12-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-common-subsequence/","title":"Longest Common Subsequence"},{"content":"5. 最长回文子串 分析 中心扩展思想： 回文的中心可以是一个字符（如 aba 的中心是 b），也可以是两个字符之间（如 abba 的中心是 bb） 遍历字符串的每一个字符（和每一个字符间隙）作为中心，向两侧扩展判断是否为回文子串 具体步骤： 枚举每一个可能的中心： 单字符中心：如字符 a 双字符中心：如字符对 aa 每次以当前中心向两侧扩展，直到遇到不相等的字符或边界 记录当前最长的回文子串，并与之前记录的结果进行比较，更新最长子串 时间复杂度 遍历字符串每个字符 O(n)，每次从中心向外扩展最多 O(n)，总体时间复杂度为 O(n^2)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: string longestPalindrome(string s) { // 初始化结果变量 std::string res; // 遍历字符串的每一个字符，尝试以其为中心扩展 for (int i = 0; i \u0026lt; s.size(); ++i) { // 第一种情况：中心是单个字符 int l = i - 1, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) --l, ++r; // 更新最长回文子串 if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); // 第二种情况：中心是两个字符之间 l = i, r = i + 1; while (l \u0026gt;= 0 \u0026amp;\u0026amp; r \u0026lt; s.size() \u0026amp;\u0026amp; s[l] == s[r]) --l, ++r; // 更新最长回文子串 if (res.size() \u0026lt; r - l - 1) res = s.substr(l + 1, r - l - 1); } // 返回最长回文子串 return res; } }; ","date":"2024-12-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-palindromic-substring/","title":"Longest Palindromic Substring"},{"content":"136. 只出现一次的数字 分析 异或运算具有以下性质：\nx ^ x = 0: 任何数字与自身异或结果为 0 x ^ 0 = x: 任何数字与 0 异或结果为自身 满足交换律和结合律 通过对数组中的所有数字进行异或操作，成对出现的数字会互相抵消，最终只剩下那个只出现一次的数字\n时间复杂度 总时间复杂度 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 class Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = 0; // 初始化结果为 0 for (int num : nums) // 遍历数组 res ^= num; // 将每个数字与 res 进行异或操作 return res; // 返回结果 } }; ","date":"2024-12-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/single-number/","title":"Single Number"},{"content":"64. 最小路径和 分析 状态定义：\n用 f[i][j] 表示从起点 (0, 0) 到达位置 (i, j) 的路径数字总和的最小值 状态转移：\n如果机器人可以从上方或左方到达 (i, j)，则：f[i][j] = min(f[i-1][j], f[i][j-1]) + grid[i][j]\n边界情况：\n如果位于第一行，则只能从左侧到达：f[0][j] = f[0][j-1] + grid[0][j] 如果位于第一列，则只能从上方到达：f[i][0] = f[i-1][0] + grid[i][0] 初始条件：\n起点 (0, 0) 的路径和等于网格的初始值：f[0][0] = grid[0][0] 时间复杂度 动态规划遍历整个网格，每个位置只需计算一次，时间复杂度为 O(mn)\n空间复杂度 空间复杂度为 O(mn)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { // 获取网格的行数和列数 int n = grid.size(); if (n == 0) return 0; // 如果网格为空，直接返回 0 int m = grid[0].size(); // 初始化动态规划数组，所有值初始为 INT_MAX std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n, std::vector\u0026lt;int\u0026gt;(m, INT_MAX)); // 动态规划计算每个位置的最小路径和 for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { if (i == 0 \u0026amp;\u0026amp; j == 0) // 起点 f[i][j] = grid[i][j]; else { // 从上方到达 if (i) f[i][j] = std::min(f[i][j], f[i - 1][j] + grid[i][j]); // 从左方到达 if (j) f[i][j] = std::min(f[i][j], f[i][j - 1] + grid[i][j]); } } } // 返回右下角的最小路径和 return f[n - 1][m - 1]; } }; ","date":"2024-12-12T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/minimum-path-sum/","title":"Minimum Path Sum"},{"content":"416. 分割等和子集 分析 典型的 01 背包问题，我们需要判断是否存在一个子集，其元素和为 sum / 2，其中 sum 是数组 nums 的元素总和\n特殊情况处理： 如果数组总和 sum 是奇数，则无法分成两个相等的子集，直接返回 false 动态规划定义： 定义一个布尔数组 f，其中 f[j] 表示是否可以从数组中选取一些元素，使得这些元素的和为 j 初始化 f[0] = true，表示总和为 0 的情况总是成立（即不选任何元素） 状态转移方程： 遍历数组 nums 中的每个数 nums[i]，从目标值 target 开始往下更新： f[j] = f[j] || f[j - nums[i]] 表示如果在之前能凑出 j - nums[i]，则加入当前数字后也能凑出 j 最终结果： 如果能凑出目标值 sum / 2，即 f[target] == true，则可以分成两个相等的子集 时间复杂度 外层循环遍历数组 n 次 内层循环遍历目标值 target 次 总时间复杂度 O(n * target)\n空间复杂度 空间复杂度为 O(target)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool canPartition(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sum = 0; for (int num : nums) // 计算数组的总和 sum += num; if (sum % 2) // 如果总和是奇数，无法分割成两个相等的子集 return false; int target = sum / 2; // 目标子集的和 int n = nums.size(); std::vector\u0026lt;bool\u0026gt; f(target + 1, false); // 定义状态数组，f[j] 表示是否可以凑出总和 j f[0] = true; // 总和为 0 的情况成立 for (int i = 0; i \u0026lt; n; ++i) // 遍历每个数 for (int j = target; j \u0026gt;= nums[i]; --j) // 从 target 向下遍历，避免状态覆盖 f[j] = f[j] || f[j - nums[i]]; return f[target]; // 返回是否可以凑出目标总和 } }; ","date":"2024-12-12T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/partition-equal-subset-sum/","title":"Partition Equal Subset Sum"},{"content":"62. 不同路径 分析 状态定义： 用 f[i][j] 表示从起点 (0, 0) 到达网格位置 (i, j) 的不同路径数 状态转移： 如果机器人能够从上方或左方到达 (i, j)： 从上方到达：路径数为 f[i-1][j] 从左方到达：路径数为 f[i][j-1] 因此，状态转移方程为：f[i][j] = f[i-1][j] + f[i][j-1] 初始条件： 起点 (0, 0) 的路径数为 1，即 f[0][0] = 1 第一行和第一列的位置只能从一个方向到达： 第一行：只能从左到右 第一列：只能从上到下 时间复杂度 需要遍历整个网格，时间复杂度为 O(mn)\n空间复杂度 空间复杂度为 O(mn)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: int uniquePaths(int m, int n) { // 创建一个二维数组 f，用于记录每个位置的路径数 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f(n, std::vector\u0026lt;int\u0026gt;(m)); // 遍历每个位置 for (int i = 0; i \u0026lt; n; ++i) { for (int j = 0; j \u0026lt; m; ++j) { // 初始化起点 if (i == 0 \u0026amp;\u0026amp; j == 0) f[i][j] = 1; else { // 从上方到达 if (i) f[i][j] += f[i - 1][j]; // 从左方到达 if (j) f[i][j] += f[i][j - 1]; } } } // 返回终点的路径数 return f[n - 1][m - 1]; } }; ","date":"2024-12-12T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/unique-paths/","title":"Unique Paths"},{"content":"322. 零钱兑换 分析 定义状态： f[j]：表示凑成金额 j 所需的最少硬币个数 状态转移方程： 对于每个硬币面值 coins[i]，如果选择该硬币，那么金额 j 的状态可以由金额 j - coins[i] 转移而来：f[j] = min(f[j], f[j - coins[i]] + 1)，即当前金额的最优解为不选择当前硬币的解和选择当前硬币的解的较小值 初始化： f[0] = 0：凑成金额 0 所需的硬币数为 0 其他状态 f[j] 初始化为无穷大（设为一个较大的值 INF），表示尚未凑成 结果判断： 如果 f[amount] = INF ，表示无法凑成金额 amount，返回 -1 否则返回 f[amount] 时间复杂度 外层循环遍历硬币种类 O(n) ，内层循环遍历金额 O(amount) ，总复杂度为 O(n * amount)\n空间复杂度 空间复杂度为 O(amount)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int coinChange(vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { int INF = 0x3f3f3f3f; // 定义一个较大的值表示无穷大 std::vector\u0026lt;int\u0026gt; f(amount + 1, INF); // 初始化 DP 数组 f[0] = 0; // 金额为 0 时需要 0 个硬币 for (int i = 0; i \u0026lt; coins.size(); ++i) // 遍历每个硬币面值 { for (int j = coins[i]; j \u0026lt;= amount; ++j) // 遍历所有可能金额 { f[j] = std::min(f[j], f[j - coins[i]] + 1); // 状态转移 } } if (f[amount] == INF) // 如果金额无法凑成 return -1; return f[amount]; // 返回最优解 } }; ","date":"2024-12-11T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/coin-change/","title":"Coin Change"},{"content":"300. 最长递增子序列 分析 思路\n使用一个数组 q 来维护当前已知的递增子序列。这个数组不一定是真实的子序列，而是用于动态记录递增子序列的长度信息 遍历数组 nums 时，依次将当前数字插入到 q 中，保证 q 中的元素始终满足递增条件 处理策略：\n如果当前数字 x 大于 q 的最后一个元素，则直接追加到 q 的末尾 否则，使用 二分查找 找到 q 中第一个大于或等于 x 的位置，并用 x 替换该位置的值这相当于更新子序列，使其在同样长度的情况下更容易扩展 返回结果：\n最终数组 q 的长度即为最长递增子序列的长度 时间复杂度 遍历数组时，每个元素需要执行一次二分查找，二分查找的复杂度为 O(logn)\n总时间复杂度 O(nlogn)\n空间复杂度 空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;int\u0026gt; q; // 用于记录递增子序列的数组 for (int x : nums) { if (q.empty() || x \u0026gt; q.back()) // 如果当前数字大于子序列末尾元素 q.push_back(x); // 直接追加 else { // 使用二分查找定位 int l = 0, r = q.size() - 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; // 中间位置 if (x \u0026lt;= q[mid]) // 如果当前数字小于等于 q[mid] r = mid; // 缩小右边界 else l = mid + 1; // 缩小左边界 } q[r] = x; // 替换第一个大于等于 x 的位置 } } return q.size(); // q 的长度即为最长递增子序列的长度 } }; ","date":"2024-12-11T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-increasing-subsequence/","title":"Longest Increasing Subsequence"},{"content":"139. 单词拆分 分析 状态定义： 定义 f[i]：表示从第 i 个字符到字符串结尾的子串能否被字典中的单词拼接而成 状态转移： 对于子串 s[i:j]，若 s[i:j] 出现在字典中，且 f[j] = true，则可以拼接出 s[i:n]，即 f[i] = true 初始化： f[n] = true：空字符串可以被成功拼接 结果： 返回 f[0]，即判断整个字符串是否可以被拼接 时间复杂度 外层循环遍历字符串 O(n) ，内层循环遍历每个子串的结尾 O(n) ，检查子串是否在字典中平均耗时 O(k) ，其中 k 是子串的平均长度 总时间复杂度为 O(n^2 * k)\n空间复杂度 动态规划数组 f 占用 O(n) 哈希表占用 O(l) ，其中 l 是字典中单词的总长度 总空间复杂度为 O(n + l)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { std::unordered_set\u0026lt;std::string\u0026gt; hash; // 使用哈希表存储字典中的单词 for (std::string word : wordDict) hash.insert(word); int n = s.size(); std::vector\u0026lt;bool\u0026gt; f(n + 1, false); // 动态规划数组 f[n] = true; // 初始化空字符串为可拼接 // 从后向前遍历字符串 for (int i = n - 1; i \u0026gt;= 0; --i) { std::string str; // 记录当前子串 for (int j = i; j \u0026lt; n; ++j) { str += s[j]; // 扩展子串 if (hash.count(str) \u0026amp;\u0026amp; f[j + 1]) // 检查是否满足条件 { f[i] = true; break; } } } return f[0]; // 返回结果 } }; ","date":"2024-12-11T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/word-break/","title":"Word Break"},{"content":"70. 爬楼梯 分析 典型的斐波那契数列问题。到达第 n 阶的方法数等于到达第 n-1 阶和第 n-2 阶的方法数之和 状态转移方程：f(n) = f(n-1) + f(n-2)\n初始条件：\nf(0) = 1 ：到达第 1 阶的方法只有一种 f(1) = 1 ：到达第 1 阶的方法只有一种 f(2) = 2 ：到达第 2 阶的方法是两种 1 + 1 通过观察状态转移公式，问题可以转化为计算斐波那契数列的第 n 项 使用两个变量来存储状态值，优化空间复杂度： a ：表示到达前一阶的方法数 b ：表示到达当前阶的方法数 迭代更新 a 和 b 的值，直到计算到第 n 阶 时间复杂度 循环执行 n - 1 次，时间复杂度为 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int climbStairs(int n) { int a = 1, b = 1; // 初始状态：f(0) = 1, f(1) = 1 while ( -- n) // 从第 2 阶开始计算 { int c = a + b; // 当前阶方法数等于前两阶之和 a = b; // 更新前一阶为当前阶 b = c; // 更新当前阶为下一阶 } return b; // 返回第 n 阶的方法数 } }; ","date":"2024-12-10T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/climbing-stairs/","title":"Climbing Stairs"},{"content":"198. 打家劫舍 分析 定义状态： f[i]：表示偷取第 i 个房屋的最高金额 g[i]：表示不偷取第 i 个房屋的最高金额 状态转移方程： 若偷第 i 个房屋：f[i] = g[i - 1] + nums[i - 1]，即前一个房屋没有被偷，当前房屋可以偷取，累加其金额。 若不偷第 i 个房屋：g[i] = max(f[i - 1], g[i - 1])，即第 i 个房屋不被偷，其最优结果取决于前一个房屋偷或不偷的最大值 初始化： f[0] = 0（没有房屋可偷） g[0] = 0 （没有房屋可偷） 结果： 最终的最大金额为：max(f[n], g[n]) 时间复杂度 遍历一次数组，时间复杂度为 O(n)\n空间复杂度 使用两个长度为 n + 1 的数组，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); std::vector\u0026lt;int\u0026gt; f(n + 1), g(n + 1); // 定义偷和不偷的状态数组 for (int i = 1; i \u0026lt;= n; ++ i) { f[i] = g[i - 1] + nums[i - 1]; // 偷当前房屋 g[i] = std::max(f[i - 1], g[i - 1]); // 不偷当前房屋 } return std::max(f[n], g[n]); // 返回最大值 } }; ","date":"2024-12-10T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/house-robber/","title":"House Robber"},{"content":"118. 杨辉三角 分析 杨辉三角的特点是：\n第 i 行有 i 个元素 每行的首尾元素为 1 中间的每个元素为其上一行相邻两个元素的和 公式：f[i][j] = f[i-1][j-1] + f[i-1][j]\n初始化数据结构： 使用一个二维数组 f 存储结果 逐行构造杨辉三角： 第 i 行初始化一个大小为 i + 1 的数组 设置首尾元素为 1 遍历中间位置，根据公式计算值并填充 返回结果： 将每一行加入结果数组并返 时间复杂度 外层循环运行 n 次； 内层循环最多运行 n - 2 次 总体复杂度为：O(1 + 2 + 3 + ... + n) = O(n^2)\n空间复杂度 空间复杂度为 O(n^2)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; generate(int numRows) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; f; for (int i = 0; i \u0026lt; numRows; ++ i) // 遍历每一行 { std::vector\u0026lt;int\u0026gt; line(i + 1); // 初始化当前行，长度为 i+1 line[0] = line[i] = 1; // 每行的首尾元素为 1 for (int j = 1; j \u0026lt; i; ++ j) // 中间元素由上一行相邻元素之和计算得出 line[j] = f[i - 1][j - 1] + f[i - 1][j]; f.push_back(line); // 将当前行加入结果数组 } return f; } }; ","date":"2024-12-10T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/pascals-triangle/","title":"Pascals Triangle"},{"content":"279. 完全平方数 分析 定义状态： f[i] ：表示和为 i 的完全平方数的最少数量 状态转移方程： 对于 i ，尝试减去一个完全平方数 j^2 ，转移状态为：f[i] = min(f[i], f[i - j^2] + 1) 初始化： f[0] = 0 ：和为 0 的最少数量为 0 其他状态 f[i] 初始化为 4，因为根据四平方和定理，一个数至多由 4 个完全平方数组成 遍历顺序： 外层循环遍历 i（目标和），内层循环遍历 j（尝试的完全平方数） 结果： 返回 f[n] 即为和为 n 的完全平方数的最少数量 时间复杂度 外层循环遍历 i 从 1 到 n，内层循环枚举完全平方数的数量，最多为 \\sqrt{n} 总复杂度为 O(n*\\sqrt{n})\n空间复杂度 使用排序 O(logn) 的额外空间，其余操作在原地完成，空间复杂度为 O(1)\n使用了长度为 n + 1 的数组 f，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: int numSquares(int n) { std::vector\u0026lt;int\u0026gt; f(n + 1, 4); // 初始化 f 数组，最大值为 4 f[0] = 0; // 和为 0 时的最少数量为 0 for (int i = 1; i \u0026lt;= n; ++i) { for (int j = 1; j * j \u0026lt;= i; ++j) { f[i] = std::min(f[i], f[i - j * j] + 1); // 状态转移 } } return f[n]; // 返回结果 } }; ","date":"2024-12-10T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/perfect-squares/","title":"Perfect Squares"},{"content":"295. 数据流的中位数 分析 为了高效地获取中位数，使用 两个优先队列（堆） 来维护数据流的有序性：\ndown 堆（大顶堆）： 存储较小的一半元素，堆顶是最大值 up 堆（小顶堆）： 存储较大的一半元素，堆顶是最小值 通过以下规则维持堆的平衡和正确性：\n插入元素： 如果当前元素小于或等于 down 堆的堆顶，将其插入 down 否则，将其插入 up 调整堆的平衡： 如果 down 的元素个数比 up 多 2，将 down 堆顶移到 up 如果 up 的元素个数比 down 多 1，将 up 堆顶移到 down 计算中位数： 如果两个堆的元素个数相等，中位数为两个堆顶的平均值； 如果 down 堆的元素个数比 up 多 1，中位数为 down 堆顶的值 时间复杂度 插入操作：O(logn) （堆的插入与删除） 获取中位数：O(1) 总体复杂度：O(logn) （单次操作）\n空间复杂度 使用两个堆存储所有元素，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class MedianFinder { public: // 大顶堆，存储较小的一半元素 std::priority_queue\u0026lt;int\u0026gt; down; // 小顶堆，存储较大的一半元素 std::priority_queue\u0026lt;int, std::vector\u0026lt;int\u0026gt;, std::greater\u0026lt;int\u0026gt;\u0026gt; up; MedianFinder() {} void addNum(int num) { // 插入到适当的堆 if (down.empty() || num \u0026lt;= down.top()) down.push(num); else up.push(num); // 调整堆的平衡 if (down.size() == up.size() + 2) { int x = down.top(); down.pop(); up.push(x); } else if (down.size() + 1 == up.size()) { int x = up.top(); up.pop(); down.push(x); } } double findMedian() { if (down.size() == up.size()) return (down.top() + up.top()) / 2.0; return down.top(); } }; ","date":"2024-12-09T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/find-median-from-data-stream/","title":"Find Median From Data Stream"},{"content":"215. 数组中的第K个最大元素 分析 分区过程：\n使用双指针 i 和 j ： i 向右找到第一个小于等于基准值的元素； j 向左找到第一个大于等于基准值的元素； 交换 i 和 j 的位置，确保左侧元素大于基准值，右侧元素小于基准值 递归判断：\n若 k 小于等于划分点索引 j ，说明目标在左区间； 若 k 大于划分点索引 j ，说明目标在右区间； 继续递归查找，直到缩小到单元素区间 处理第 k 大：\nk 是基于第 1 个元素的索引，因此将 k - 1 转换为 0 索引形式进行处理 时间复杂度 平均情况下为 O(n) ：每次划分能排除约一半的元素 最坏情况下为 O(n^2) ：当数组退化为不平衡分区时 空间复杂度 O(log n)：递归栈的深度，取决于分区的层数\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: // 快速排序分治查找第 k 大元素 int quick_sort(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int l, int r, int k) { // 当区间缩小到单个元素时，返回该元素 if (l == r) return nums[k]; // 基准值选择第一个元素 int x = nums[l], i = l - 1, j = r + 1; // 快速排序分区过程：双指针划分 while (i \u0026lt; j) { do ++i; while (nums[i] \u0026gt; x); // 找到左侧第一个小于等于基准值的元素 do --j; while (nums[j] \u0026lt; x); // 找到右侧第一个大于等于基准值的元素 if (i \u0026lt; j) std::swap(nums[i], nums[j]); // 交换元素使其划分到正确的区间 } // 判断第 k 大元素所在区间 if (k \u0026lt;= j) return quick_sort(nums, l, j, k); // 在左侧区间 else return quick_sort(nums, j + 1, r, k); // 在右侧区间 } // 主函数：寻找第 k 大元素 int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { return quick_sort(nums, 0, nums.size() - 1, k - 1); // 转换为 0 索引 } }; ","date":"2024-12-09T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/kth-largest-element-in-an-array/","title":"Kth Largest Element In An Array"},{"content":"84. 柱状图中的最大矩形 分析 确定左右边界：\n左边界：对于柱子 heights[i]，寻找它左边第一个比它小的柱子位置 left[i] 使用一个单调递增栈，从左到右遍历数组： 当前柱子比栈顶柱子低时，弹出栈顶柱子，找到当前柱子作为某柱右边界的场景 当前柱子的左边界就是栈顶元素（若栈为空，则左边界为 -1） 右边界：对于柱子 heights[i]，寻找它右边第一个比它小的柱子位置 right[i] 使用相同逻辑，从右向左遍历数组，确定每个柱子的右边界 利用单调栈快速找到这些边界 计算最大矩形面积：\n每个柱子的宽度 = right[i] - left[i] - 1 面积 = 柱高度 × 宽度，取最大值 时间复杂度 每个柱子在左右边界的遍历中最多进栈和出栈一次，总时间复杂度为 O(n)\n空间复杂度 需要存储左右边界和栈，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { int n = heights.size(); std::vector\u0026lt;int\u0026gt; left(n), right(n); // 左边界和右边界 std::stack\u0026lt;int\u0026gt; stk; // 确定左边界 for (int i = 0; i \u0026lt; n; ++i) { while (!stk.empty() \u0026amp;\u0026amp; heights[i] \u0026lt;= heights[stk.top()]) stk.pop(); left[i] = stk.empty() ? -1 : stk.top(); stk.push(i); } // 清空栈，重新计算右边界 stk = std::stack\u0026lt;int\u0026gt;(); for (int i = n - 1; i \u0026gt;= 0; --i) { while (!stk.empty() \u0026amp;\u0026amp; heights[i] \u0026lt;= heights[stk.top()]) stk.pop(); right[i] = stk.empty() ? n : stk.top(); stk.push(i); } // 计算最大矩形面积 int res = 0; for (int i = 0; i \u0026lt; n; ++i) res = std::max(res, heights[i] * (right[i] - left[i] - 1)); return res; } }; ","date":"2024-12-09T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/largest-rectangle-in-histogram/","title":"Largest Rectangle In Histogram"},{"content":"347. 前K个高频元素 分析 统计频率： 使用哈希表 hash 记录数组中每个元素的出现次数，键为数组元素，值为对应频率 统计频率分布： 创建一个计数数组 count，其中 count[i] 表示频率为 i 的元素个数 确定频率阈值： 从高频到低频累加 count，直到累计的元素数达到 k ，此时的频率即为筛选阈值 i 筛选元素： 再次遍历哈希表 hash，将频率大于阈值 i 的元素加入结果数组 res 时间复杂度 统计频率：O(n) ，遍历数组 统计频率分布：O(m) ，m 为哈希表的大小 筛选元素：O(m) 总复杂度：O(n + m) ，其中 m \u0026lt;= n\n空间复杂度 哈希表存储频率： O(m) 频率分布数组：O(n) 总复杂度：O(n + m)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: vector\u0026lt;int\u0026gt; topKFrequent(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { // 1. 统计每个元素的频率 std::unordered_map\u0026lt;int, int\u0026gt; hash; for (int num : nums) ++hash[num]; // 2. 统计每个频率的出现次数 int n = nums.size(); std::vector\u0026lt;int\u0026gt; count(n + 1); for (std::pair\u0026lt;int, int\u0026gt; item : hash) ++count[item.second]; // 3. 找到频率阈值 int i = n, sum = 0; while (sum \u0026lt; k) sum += count[i--]; // 4. 筛选出符合条件的元素 std::vector\u0026lt;int\u0026gt; res; for (std::pair\u0026lt;int, int\u0026gt; item : hash) if (item.second \u0026gt; i) res.push_back(item.first); return res; } }; ","date":"2024-12-09T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/top-k-frequent-elements/","title":"Top K Frequent Elements"},{"content":"739. 每日温度 分析 倒序遍历： 从最后一天向第一天遍历温度数组 因为从后向前，可以快速找到当前温度后面更高的温度 使用单调递减栈： 栈中保存数组的下标，保证栈内元素对应的温度单调递减 每次遇到更高的温度时，将栈顶元素弹出，更新结果数组 计算结果： 如果栈不为空，当前栈顶元素对应的温度是下一个更高温度，计算两者下标的差值 如果栈为空，表示后面没有更高温度，结果置为 0 将当前天的下标压入栈，供后续处理 时间复杂度 每个元素最多被压栈和弹栈一次，总时间复杂度 O(n)\n空间复杂度 使用了一个栈，最坏情况下栈中可能存储所有天数，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; temperatures) { // 初始化结果数组，长度与输入数组相同，初始值为 0 std::vector\u0026lt;int\u0026gt; res(temperatures.size()); // 单调栈，存储下标 std::stack\u0026lt;int\u0026gt; stk; // 从后向前遍历温度数组 for (int i = temperatures.size() - 1; i \u0026gt;= 0; --i) { // 弹出所有不满足更高温度条件的栈顶元素 while (!stk.empty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stk.top()]) stk.pop(); // 如果栈不为空，计算下标差值作为结果 if (!stk.empty()) res[i] = stk.top() - i; // 将当前下标压入栈 stk.push(i); } return res; } }; ","date":"2024-12-08T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/daily-temperatures/","title":"Daily Temperatures"},{"content":"394. 字符串解码 分析 使用两个栈： 一个存储重复次数 nums 一个存储当前解码过程中尚未完成的字符串 strs 遍历输入字符串 s： 如果是数字字符 isdigit()，将其加入当前数字 num，用于解析多位数字 如果是左括号 '['，将当前数字 num 和当前字符串 str 压栈，并重置 num 和 str 如果是右括号 ']'： 弹出栈顶的数字 n（重复次数） 弹出栈顶的字符串（上一级未完成的字符串） 将当前字符串重复 n 次后附加到弹出的字符串中，作为当前解码结果 如果是普通字符，直接加入当前字符串 str 最后返回构造好的字符串 时间复杂度 每个字符都会被处理一次，栈操作均为 O(1) ，总时间复杂度 O(n^2)\n空间复杂度 需要两个栈来存储数字和字符串，栈的最大深度取决于嵌套层数，空间复杂度为 O(m)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public: string decodeString(string s) { // 栈 nums 保存每段的重复次数，栈 strs 保存每段解码的部分字符串 std::stack\u0026lt;int\u0026gt; nums; std::stack\u0026lt;std::string\u0026gt; strs; int num = 0; // 当前数字（重复次数） std::string str; // 当前构造的字符串 for (int i = 0; i \u0026lt; s.size(); ++i) { if (std::isdigit(s[i])) { // 累积数字，支持多位数字解析 num = num * 10 + s[i] - \u0026#39;0\u0026#39;; } else if (s[i] == \u0026#39;[\u0026#39;) { // 遇到 \u0026#39;[\u0026#39;，将当前数字和字符串压栈 nums.push(num); strs.push(str); num = 0; // 重置 num str = \u0026#34;\u0026#34;; // 重置当前字符串 } else if (s[i] == \u0026#39;]\u0026#39;) { // 遇到 \u0026#39;]\u0026#39;，进行解码 int n = nums.top(); // 获取当前的重复次数 nums.pop(); std::string cur = str; // 当前字符串 str = strs.top(); // 获取上一层未完成的字符串 strs.pop(); // 将当前字符串重复 n 次并追加到上一层字符串后 while (n--) str += cur; } else { // 普通字符直接追加到当前字符串中 str += s[i]; } } return str; } }; ","date":"2024-12-08T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/decode-string/","title":"Decode String"},{"content":"155. 最小栈 分析 为了支持常数时间获取最小值，可以使用两个栈：\n主栈（stk）： 保存所有入栈的元素\n辅助栈（f）： 保存每次操作后的当前最小值\n每当一个值入栈时，如果它小于或等于当前最小值f.top()，将其压入辅助栈 当一个值出栈时，如果它等于辅助栈的栈顶，也从辅助栈中弹出 时间复杂度 push、pop、top 和 getMin 的时间复杂度均为 O(1) ，因为每个操作只涉及栈的入栈、出栈或访问栈顶\n空间复杂度 主栈 stk 存储所有元素，占用 O(n) 空间 辅助栈 f 最多存储所有元素，占用 O(n) 空间 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class MinStack { public: std::stack\u0026lt;int\u0026gt; stk; // 主栈，存储所有元素 std::stack\u0026lt;int\u0026gt; f; // 辅助栈，存储当前最小值 MinStack() { // 构造函数，初始化空栈 } void push(int val) { stk.push(val); // 将值压入主栈 // 若辅助栈为空或当前值小于等于栈顶最小值，将其压入辅助栈 if (f.empty() || val \u0026lt;= f.top()) f.push(val); } void pop() { // 若主栈栈顶元素等于辅助栈栈顶元素，同时弹出两个栈的栈顶元素 if (stk.top() == f.top()) f.pop(); stk.pop(); } int top() { return stk.top(); // 返回主栈栈顶元素 } int getMin() { return f.top(); // 返回辅助栈栈顶元素，即当前最小值 } }; ","date":"2024-12-08T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/min-stack/","title":"Min Stack"},{"content":"4. 寻找两个正序数组的中位数 分析 采用 二分查找 的方法，避免直接合并数组：\n总长度奇偶性判断： 如果两个数组合并后的长度为奇数，只需找到第 total / 2 + 1 小的数 如果为偶数，需找到第 total / 2 和第 total / 2 + 1 小的数，然后取平均值 递归查找第 k 小的数： 边界条件（递归终止条件）： 如果一个数组为空，直接返回另一个数组中的第 k 小的数 如果 k = 1，返回两个数组当前起点的较小值 二分递归： 比较两个数组中第 k / 2 小的元素 较小的那一部分不可能包含第 k 小的数，因此可以直接从数组中排除 递归更新起始位置和 k 的值 时间复杂度 每次递归将搜索范围缩小一半，因此时间复杂度为 O(log(min(m, n)))\n空间复杂度 空间复杂度为递归调用的栈空间，最大为 O(log(min(m, n)))\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { // 计算总长度 int total = nums1.size() + nums2.size(); // 如果总长度为偶数，需找到中间两个数并取平均值 if (total % 2 == 0) { double left = find(nums1, 0, nums2, 0, total / 2); double right = find(nums1, 0, nums2, 0, total / 2 + 1); return (left + right) / 2; } // 如果总长度为奇数，找到中间的数 return find(nums1, 0, nums2, 0, total / 2 + 1); } double find(std::vector\u0026lt;int\u0026gt;\u0026amp; nums1, int i, std::vector\u0026lt;int\u0026gt;\u0026amp; nums2, int j, int k) { // 让 nums1 始终是较短的数组 if (nums1.size() - i \u0026gt; nums2.size() - j) return find(nums2, j, nums1, i, k); // 边界条件：nums1 已经为空 if (nums1.size() - i == 0) return nums2[j + k - 1]; // 边界条件：k = 1，直接返回两数组当前起点的较小值 if (k == 1) return std::min(nums1[i], nums2[j]); // 二分查找 int mid1 = std::min((int)nums1.size() - 1, i + k / 2 - 1); int mid2 = j + k / 2 - 1; if (nums1[mid1] \u0026gt; nums2[mid2]) // 排除 nums2 前 (mid2 - j + 1) 个元素 return find(nums1, i, nums2, mid2 + 1, k - (mid2 - j + 1)); else // 排除 nums1 前 (mid1 - i + 1) 个元素 return find(nums1, mid1 + 1, nums2, j, k - (mid1 - i + 1)); } }; ","date":"2024-12-07T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/median-of-two-sorted-arrays/","title":"Median of Two Sorted Arrays"},{"content":"43. 字符串相乘 分析 倒序存储数字\n将 num1 和 num2 中的每一位字符转为整数，并倒序存入数组 A 和 B 。这样可以方便从低位开始模拟乘法 模拟乘法逐位累加\n两个长度分别为 n 和 m 的数字相乘，结果最多有 n + m 位 使用两个倒序数组 A 和 B ，逐位计算乘积，并将结果累加到结果数组 C 中： 对于 A[i] * B[j] ，结果累加到 C[i + j] 处理进位\n遍历结果数组 C ，将每位上的数处理为个位，进位部分加到下一位 移除前导零并生成结果字符串\n从结果数组的高位向低位查找第一个非零位，忽略高位多余的零 将结果数组转为字符串输出 时间复杂度 两个数字的长度分别为 n 和 m 遍历两者进行乘法计算，需要 O(n * m) 进位处理和结果拼接的时间为 O(n + m) 总体时间复杂度为 O(n * m)\n空间复杂度 结果数组 C 的长度为 n + m 空间复杂度为 O(n + m)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public: string multiply(string num1, string num2) { // 获取两个字符串的长度 int n = num1.size(), m = num2.size(); // 将 num1 和 num2 转换为倒序数组 A 和 B std::vector\u0026lt;int\u0026gt; A, B; for (int i = n - 1; i \u0026gt;= 0; --i) A.push_back(num1[i] - \u0026#39;0\u0026#39;); for (int i = m - 1; i \u0026gt;= 0; --i) B.push_back(num2[i] - \u0026#39;0\u0026#39;); // 初始化结果数组 C，最大长度为 n + m std::vector\u0026lt;int\u0026gt; C(n + m, 0); // 模拟乘法逐位累加 for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; m; ++j) C[i + j] += A[i] * B[j]; // 处理进位 for (int i = 0, t = 0; i \u0026lt; C.size(); ++i) { t += C[i]; C[i] = t % 10; // 当前位保留个位 t /= 10; // 进位部分 } // 移除高位多余的零 int k = C.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; C[k] == 0) --k; // 将结果数组转换为字符串 std::string res; while (k \u0026gt;= 0) res += C[k--] + \u0026#39;0\u0026#39;; return res; } }; ","date":"2024-12-07T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/multiply-strings/","title":"Multiply Strings"},{"content":"838. 推多米诺 分析 字符串首尾哨兵添加：\n为简化边界条件处理，在字符串首部添加 'L'，尾部添加 'R'，变成 dominoes = 'L' + dominoes + 'R' 这样首尾骨牌始终有确定的受力方向 预处理左右最近的受力源：\n定义两个数组 l 和 r： l[i] 表示索引 i 左侧最近的 'L' 的位置； r[i] 表示索引 i 右侧最近的 'R' 的位置 遍历计算： 从左向右遍历填充 l，记录每个位置最近的 'L'； 从右向左遍历填充 r，记录每个位置最近的 'R' 根据受力平衡更新状态：\n遍历每个位置，根据 l[i] 和 r[i] 的值判断受力方向： 如果 dominoes[l[i]] == 'L' \u0026amp;\u0026amp; dominoes[r[i]] == 'R'，受力平衡，骨牌保持竖立 '.'； 如果两侧的受力方向一致，骨牌倒向对应方向； 如果受力方向不同且距离不同，骨牌倒向距离近的一侧； 如果受力方向不同且距离相等，骨牌保持竖立 '.' 移除哨兵：\n返回字符串 dominoes.substr(1, n - 2)，移除首尾哨兵 时间复杂度 遍历三次字符串：分别计算 l 和 r 的值，以及最终更新 dominoes 的状态\n总时间复杂度 O(n)\n空间复杂度 空间复杂度：O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public: string pushDominoes(string dominoes) { // 添加哨兵 dominoes = \u0026#39;L\u0026#39; + dominoes + \u0026#39;R\u0026#39;; int n = dominoes.size(); std::vector\u0026lt;int\u0026gt; l(n), r(n); // 记录左侧最近的\u0026#39;L\u0026#39; int pos = 0; for (int i = 1; i \u0026lt; n; ++i) { if (dominoes[i] != \u0026#39;.\u0026#39;) pos = i; // 更新最近的\u0026#39;L\u0026#39;或\u0026#39;R\u0026#39; l[i] = pos; // 保存当前位置左侧的最近受力源 } // 记录右侧最近的\u0026#39;R\u0026#39; for (int i = n - 1; i \u0026gt;= 0; --i) { if (dominoes[i] != \u0026#39;.\u0026#39;) pos = i; // 更新最近的\u0026#39;L\u0026#39;或\u0026#39;R\u0026#39; r[i] = pos; // 保存当前位置右侧的最近受力源 } // 判断骨牌最终的状态 for (int i = 0; i \u0026lt; n; ++i) { if (dominoes[l[i]] == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; dominoes[r[i]] == \u0026#39;R\u0026#39;) { dominoes[i] = \u0026#39;.\u0026#39;; // 平衡受力 } else if (dominoes[l[i]] == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; dominoes[r[i]] == \u0026#39;L\u0026#39;) { dominoes[i] = \u0026#39;L\u0026#39;; // 受左侧\u0026#39;L\u0026#39;影响 } else if (dominoes[l[i]] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; dominoes[r[i]] == \u0026#39;R\u0026#39;) { dominoes[i] = \u0026#39;R\u0026#39;; // 受右侧\u0026#39;R\u0026#39;影响 } else { // 受不同方向影响，根据距离判断 if (i - l[i] \u0026lt; r[i] - i) dominoes[i] = \u0026#39;R\u0026#39;; else if (i - l[i] \u0026gt; r[i] - i) dominoes[i] = \u0026#39;L\u0026#39;; else dominoes[i] = \u0026#39;.\u0026#39;; } } // 移除首尾哨兵 return dominoes.substr(1, n - 2); } }; ","date":"2024-12-07T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/push-dominoes/","title":"Push Dominoes"},{"content":"34. 在排序数组中查找元素的第一个和最后一个位置 分析 寻找左边界：\n目标是找到 target 在数组中的最左侧位置 每次检查 nums[mid]是否大于等于 target 如果是，则缩小右边界 r = mid，以确保找到第一个出现的目标值 如果左边界不存在（即数组中没有 target），直接返回 [-1, -1] 寻找右边界：\n目标是找到 target 在数组中的最右侧位置 每次检查 nums[mid] 是否小于等于 target 如果是，则缩小左边界 l = mid，确保找到最后一个出现的目标值 只有在左边界存在时，才会继续找右边界 时间复杂度 每次二分查找的时间复杂度为 O(log n)，总共两次，因此时间复杂度为 O(log n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { // 如果数组为空，直接返回 if (nums.empty()) return {-1, -1}; // 第一次二分查找左边界 int l = 0, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; // 中间位置 if (target \u0026lt;= nums[mid]) r = mid; // 缩小右边界 else l = mid + 1; // 缩小左边界 } // 检查左边界是否存在 if (nums[r] != target) return {-1, -1}; int L = r; // 记录左边界 // 第二次二分查找右边界 l = 0, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; // 中间位置，偏向右 if (target \u0026gt;= nums[mid]) l = mid; // 缩小左边界 else r = mid - 1; // 缩小右边界 } // 返回左右边界 return {L, r}; } ","date":"2024-12-06T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/find-first-and-last-postion-of-element-in-sorted-array/","title":"Find First and Last Postion of Element In Sorted Array"},{"content":"153. 寻找旋转排序数组中的最小值 分析 未旋转情况：\n如果数组的首元素小于尾元素，说明数组未旋转，直接返回 nums[0] 二分查找旋转点：\n在旋转数组中，最小值位于右部分的起点。 使用二分查找，通过比较 nums[mid] 和 nums[0] 的值，可以判断最小值的所在位置： 如果 nums[mid] \u0026gt;= nums[0]，说明最小值在右侧，缩小左边界 如果 nums[mid] \u0026lt; nums[0]，说明最小值在左侧或当前 mid 是最小值，缩小右边界 最终，r + 1 指向最小值的位置 时间复杂度 二分查找的时间复杂度为 O(logn)\n空间复杂度 使用常量级额外空间，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // 如果数组未旋转，直接返回首元素 if (nums[0] \u0026lt;= nums[n - 1]) return nums[0]; int l = 0, r = n - 1; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; // 取中间值 if (nums[0] \u0026lt;= nums[mid]) l = mid; // 最小值在右侧 else r = mid - 1; // 最小值在左侧 } return nums[r + 1]; // 返回最小值 } }; ","date":"2024-12-06T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/find-minimum-in-rotated-sorted-array/","title":"Find Minimum in Rotated Sorted Array"},{"content":"51. N皇后 分析 棋盘表示： 使用一个长度为 n 的字符串数组 path 表示棋盘，每个字符串表示棋盘的一行，'.' 表示空格，'Q\u0026rsquo; 表示皇后 res 保存所有可能的棋盘方案 冲突检测： 使用三个布尔数组记录皇后占据的列和对角线： col[i] 表示第 i 列是否有皇后 dg[i] 表示正对角线是否有皇后（从左上到右下，索引为 u - i + n） 正对角线元素使用索引u - i来表示，因为正对角线上的元素都满足坐标x - y == 0 棋盘上所有元素坐标之差范围是-(n - 1) ~ n - 1，加偏移量 n 将其映射为1 ~ 2n - 1 udg[i] 表示反对角线是否有皇后（从右上到左下，索引为 u + i） 反对角线元素使用u + i来表示，因为反对角线上的元素都满足坐标x + y == n 棋盘上所有元素坐标之和范围为0 ~ 2(n - 1)，因此不需要加偏移量 回溯放置皇后： 从第 u 行开始，尝试在每一列放置皇后 如果当前列、正对角线、反对角线均未被占用，则将皇后放置在对应位置，并标记这些区域为占用 递归尝试放置下一行的皇后 回溯时，将皇后移除，并恢复状态 结果保存： 当递归到最后一行 u == n 时，说明当前方案有效，将棋盘方案保存到结果中 时间复杂度 每一行最多有 n 个选择，搜索深度为 n，回溯过程的总时间复杂度约为 O(n!)\n空间复杂度 需要存储棋盘状态 path 和标记数组（col、dg、udg），每个的大小为 O(n)\n总空间复杂度为 O(n²)，主要用于存储结果\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; res; // 存储所有有效的棋盘方案 std::vector\u0026lt;std::string\u0026gt; path; // 当前棋盘状态 std::vector\u0026lt;bool\u0026gt; col, dg, udg; // 列、正对角线、反对角线的占用状态 vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { // 初始化棋盘和标记数组 path = std::vector\u0026lt;std::string\u0026gt;(n, std::string(n, \u0026#39;.\u0026#39;)); col = std::vector\u0026lt;bool\u0026gt;(n); dg = std::vector\u0026lt;bool\u0026gt;(2 * n); udg = std::vector\u0026lt;bool\u0026gt;(2 * n); // 开始回溯 dfs(n, 0); return res; } void dfs(int n, int u) { // 如果所有行都放置完成，保存当前棋盘方案 if (u == n) { res.push_back(path); return; } // 遍历当前行的每一列，尝试放置皇后 for (int i = 0; i \u0026lt; n; ++i) { if (!col[i] \u0026amp;\u0026amp; !dg[u - i + n] \u0026amp;\u0026amp; !udg[u + i]) // 检查是否冲突 { // 放置皇后并标记状态 col[i] = dg[u - i + n] = udg[u + i] = true; path[u][i] = \u0026#39;Q\u0026#39;; // 递归放置下一行 dfs(n, u + 1); // 回溯：移除皇后并恢复状态 path[u][i] = \u0026#39;.\u0026#39;; col[i] = dg[u - i + n] = udg[u + i] = false; } } } }; ","date":"2024-12-06T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/n-queens/","title":"N Queens"},{"content":"35. 搜索插入位置 分析 定义搜索范围： 使用两个指针 l 和 r 分别表示数组的左边界和右边界，初始值为 0 和 nums.size() 注意右边界初始值为 nums.size()，因为我们需要处理目标值可能插入在数组末尾的情况 进行二分查找： 计算中间位置 mid = (l + r) \u0026gt;\u0026gt; 1 如果 target \u0026lt;= nums[mid]： target 可能在 mid 位置或其左侧，更新右边界 r = mid 如果 target \u0026gt; nums[mid]： target 一定在 mid 右侧，更新左边界 l = mid + 1 返回结果： 最终，l 和 r 会收敛到目标值的位置 如果 target 不在数组中，返回的是它应该插入的位置 时间复杂度 二分查找的时间复杂度为 O(log n)，其中 n 是数组长度\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int l = 0, r = nums.size(); while (l \u0026lt; r) // 当左边界小于右边界时，继续搜索 { int mid = (l + r) \u0026gt;\u0026gt; 1; // 计算中点 if (target \u0026lt;= nums[mid]) r = mid; // 缩小右边界，可能找到目标或插入点 else l = mid + 1; // 缩小左边界 } return r; // 返回插入位置 } ","date":"2024-12-06T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/search-insert-position/","title":"Search Insert Position"},{"content":"39. 数组总和 分析 使用深度优先搜索（DFS）+ 回溯的方法 遍历候选数组 candidates 时，允许重复选择当前数字，目标值 target 减去选中的数字，直到达到目标（target == 0） 若 target 不为 0，但已遍历完数组，表示当前路径无解，返回上一层 回溯时移除已选择的数字 关键：每次递归时，既允许不选当前数字，也允许多次选取当前数字\n时间复杂度 最坏情况下，candidates 长度为 n，每次递归中需要尝试所有可能的组合，时间复杂度为 O(2^n)\n空间复杂度 递归深度为 target / min(candidates)，路径存储需要 O(target / min(candidates))\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; // 存储结果集 std::vector\u0026lt;int\u0026gt; path; // 当前路径 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { dfs(candidates, 0, target); // 从第一个数字开始递归 return res; } void dfs(std::vector\u0026lt;int\u0026gt;\u0026amp; candidates, int u, int target) { if (target == 0) { // 目标值为0，找到一种组合 res.push_back(path); return; } if (u == candidates.size()) // 遍历完所有数字 return; // 尝试选择当前数字若干次 for (int i = 0; i * candidates[u] \u0026lt;= target; ++i) { dfs(candidates, u + 1, target - i * candidates[u]); // 递归 path.push_back(candidates[u]); // 将当前数字加入路径 } for (int i = 0; i * candidates[u] \u0026lt;= target; ++i) { path.pop_back(); // 回溯，移除当前数字 } } }; ","date":"2024-12-05T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/combination-sum/","title":"Combination Sum"},{"content":"131. 分割回文串 分析 预处理判断回文子串： 通过动态规划预处理所有可能的子串，判断每个子串是否是回文 定义二维数组 f[i][j]，表示从 i 到 j 的子串是否为回文： 若 s[i] == s[j]，且内部的子串 s[i+1:j-1] 也是回文，则 f[i][j] = true 特殊情况下（i == j 或 j == i+1），直接判断字符是否相等 回溯搜索分割方案： 从字符串的第一个字符开始尝试分割 若当前子串是回文，则将其加入路径中，继续搜索剩余部分 如果遍历完整个字符串，将当前路径保存为一种结果 搜索结束后，将最后加入路径的子串弹出，回溯到上一步继续尝试 时间复杂度 预处理回文数组：需要枚举所有子串，时间复杂度为 O(n²) 回溯搜索：每个字符有两种选择（分割或不分割），复杂度近似为 O(2ⁿ) 总体时间复杂度：O(n² + 2ⁿ)\n空间复杂度 动态规划数组 f 占用 O(n²) 递归深度最多为字符串长度 n，路径数组和递归栈占用 O(n) 总体空间复杂度：O(n²)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; res; // 存储最终结果 std::vector\u0026lt;std::string\u0026gt; path; // 当前路径 std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt; f; // 动态规划存储回文判断结果 vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; partition(string s) { int n = s.size(); // 初始化回文判断数组 f = std::vector\u0026lt;std::vector\u0026lt;bool\u0026gt;\u0026gt;(n, std::vector\u0026lt;bool\u0026gt;(n)); // 动态规划预处理回文子串 for (int j = 0; j \u0026lt; n; ++j) for (int i = 0; i \u0026lt;= j; ++i) { if (i == j) // 单个字符是回文 f[i][j] = true; else if (s[i] == s[j]) // 判断两端字符是否相等 if (i + 1 \u0026gt; j - 1 || f[i + 1][j - 1]) // 内部子串为空或回文 f[i][j] = true; } // 开始回溯搜索 dfs(s, 0); return res; } void dfs(std::string s, int u) { // 如果已经分割到字符串末尾，保存当前路径 if (u == s.size()) { res.push_back(path); return; } // 遍历从 u 开始的每个子串 for (int i = u; i \u0026lt; s.size(); ++i) if (f[u][i]) // 如果当前子串是回文 { path.push_back(s.substr(u, i - u + 1)); // 加入路径 dfs(s, i + 1); // 递归处理剩余部分 path.pop_back(); // 回溯 } } }; ","date":"2024-12-05T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/palindrome-partitioning/","title":"Palindrome Partitioning"},{"content":"79. 单词搜索 分析 遍历网格：\n使用双层循环遍历网格中的每个字符 如果发现当前字符和目标单词的首字符匹配，则从这个位置开始进行深度优先搜索 dfs()：\n检查当前网格字符是否匹配目标单词的当前字符 如果匹配，检查是否已经完成整个单词的匹配 临时将当前字符标记为已访问（用 * 替代），以防止重复访问 按照上下左右四个方向继续搜索，递归调用 dfs() 如果所有方向都无法匹配剩余字符，则将当前字符还原，返回 false 返回结果：\n如果某次 DFS 找到了目标单词，则立即返回 true 如果遍历完网格后仍未找到匹配，返回 false 时间复杂度 每个网格单元都可能作为起点触发一次深度优先搜索。 搜索深度最多为 word.length。 最坏情况下，搜索路径为网格大小 m × n 的全部单元 时间复杂度为 O(m × n × 4^l)，其中 l 是单词的长度\n空间复杂度 递归栈的深度最多为单词的长度 l，空间复杂度为 O(l)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { // 遍历整个网格 for (int i = 0; i \u0026lt; board.size(); ++ i) for (int j = 0; j \u0026lt; board[0].size(); ++ j) // 如果从某个位置开始匹配成功，直接返回true if (dfs(board, word, 0, i, j)) return true; return false; // 如果遍历完所有位置都未找到，返回false } bool dfs(std::vector\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, std::string\u0026amp; word, int u, int x, int y) { // 当前字符与目标单词的字符不匹配 if (board[x][y] != word[u]) return false; // 匹配到单词的最后一个字符，返回true if (u == word.size() - 1) return true; // 标记当前字符已访问 char temp = board[x][y]; board[x][y] = \u0026#39;*\u0026#39;; int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0}; // 四个方向数组 for (int i = 0; i \u0026lt; 4; ++ i) { int a = x + dx[i], b = y + dy[i]; // 确保新的位置不越界且未访问 if (a \u0026lt; 0 || a \u0026gt;= board.size() || b \u0026lt; 0 || b \u0026gt;= board[0].size() || board[a][b] == \u0026#39;*\u0026#39;) continue; // 递归检查下一字符是否匹配 if (dfs(board, word, u + 1, a, b)) return true; } // 恢复当前字符，继续尝试其他路径 board[x][y] = temp; return false; } }; ","date":"2024-12-05T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/word-search/","title":"Word Search"},{"content":"46. 全排列 分析 思路 每次递归选择一个未使用的数字加入当前路径，直到路径长度等于数组长度，记录当前排列 初始化 用 res 保存最终的所有排列结果 用 path 保存当前排列路径 用布尔数组 is_used 标记某个数字是否已被使用，避免重复选择 回溯逻辑 dfs 如果当前路径长度 u 等于数组长度，保存当前路径到结果集 res 中 遍历数组，对未使用的数字： 标记为已使用 将数字加入路径 递归进入下一层 回溯时取消标记并移除路径中的数字 时间复杂度 时间复杂度：O(n!)，因为共有 n! 种排列\n空间复杂度 空间复杂度：O(n)，递归调用栈深度为 n，path 和 is_used 数组均为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; // 存储最终结果 std::vector\u0026lt;int\u0026gt; path; // 当前排列路径 std::vector\u0026lt;bool\u0026gt; is_used; // 标记是否使用过当前数字 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 初始化 path 和 is_used 数组 path = std::vector\u0026lt;int\u0026gt;(nums.size()); is_used = std::vector\u0026lt;bool\u0026gt;(nums.size()); // 调用回溯函数 dfs(nums, 0); return res; } void dfs(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int u) { // 如果路径长度等于数组长度，保存结果 if (u == nums.size()) { res.push_back(path); return; } // 遍历所有数字，尝试加入当前路径 for (int i = 0; i \u0026lt; nums.size(); ++i) { if (!is_used[i]) { // 如果当前数字未使用 is_used[i] = true; // 标记当前数字已使用 path[u] = nums[i]; // 加入当前路径 dfs(nums, u + 1); // 递归生成下一个位置的数字 is_used[i] = false; // 回溯时取消标记 } } } }; ","date":"2024-12-04T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/permutations/","title":"Permutations"},{"content":"78. 子集 分析 回溯法 思路 每个元素都有两种状态：选入当前子集或不选入当前子集 对每个元素进行选择，并递归处理剩余元素 当递归到数组末尾时，将当前子集 path 加入结果集 res 步骤 用 res 存储所有子集结果 用 path 存储当前子集路径 用递归函数 dfs(nums, u) 表示从索引 u 开始构造子集 如果索引到达数组末尾，将当前路径加入结果集 否则： 跳过当前元素，继续递归 包含当前元素，继续递归，并在递归结束后回溯状态 位运算枚举 位运算思路\n每个子集可以看作长度为 n 的二进制数，每一位 1 表示对应的数组元素被选中 枚举从 0 到 2^n - 1 的所有整数，用二进制表示子集选择情况 对于每个整数： 遍历其二进制的每一位，若某一位为 1，将对应位置的数组元素加入当前子集 将生成的子集加入结果集 步骤\n初始化结果集 res 遍历从 0 到 2^n - 1 的整数，用位运算检查每一位是否为 1 若某位为 1，将对应的数组元素加入当前子集 path 枚举结束后返回结果集 res 时间复杂度 每个元素有两种状态（选或不选），总状态数为 2^n。遍历每个状态生成子集，总时间复杂度 O(n^2)\n空间复杂度 递归调用栈深度为 O(n)，路径数组 path 最多占用 O(n)，总空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; // 存储所有子集 std::vector\u0026lt;int\u0026gt; path; // 当前子集路径 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { dfs(nums, 0); // 从索引 0 开始回溯 return res; } void dfs(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int u) { // 递归终止条件：索引越界时，将当前路径加入结果集 if (u == nums.size()) { res.push_back(path); return; } // 不选择当前元素，继续递归 dfs(nums, u + 1); // 选择当前元素，加入路径并继续递归 path.push_back(nums[u]); dfs(nums, u + 1); // 回溯状态，移除当前元素 path.pop_back(); } }; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; // 存储所有子集 int n = nums.size(); // 枚举所有可能的子集，用二进制表示 for (int i = 0; i \u0026lt; (1 \u0026lt;\u0026lt; n); ++i) { std::vector\u0026lt;int\u0026gt; path; // 当前子集 for (int j = 0; j \u0026lt; n; ++j) { if ((i \u0026gt;\u0026gt; j) \u0026amp; 1) // 若第 j 位为 1，加入对应元素 path.push_back(nums[j]); } res.push_back(path); // 将当前子集加入结果集 } return res; } }; ","date":"2024-12-04T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/subsets/","title":"subsets"},{"content":"207. 课程表 分析 构建图结构与入度数组 使用邻接表 g 表示课程之间的依赖关系：对于 prerequisites[i] = [a, b]，将 b -\u0026gt; a 加入图中 使用入度数组 d 记录每个课程的入度（依赖它的先修课程数量） 初始化队列 将入度为 0 的课程（无依赖课程）加入队列 q，这些课程可以直接开始学习 拓扑排序 从队列中取出课程，计数器 res 加 1（表示完成了一门课程） 遍历该课程的邻接课程，将它们的入度减 1。如果某门课程的入度减为 0，将其加入队列 重复直到队列为空 判断是否可行 如果最终完成课程数 res 等于 numCourses，说明可以完成所有课程，返回 true 否则返回 false，表示存在环形依赖，课程无法全部完成 时间复杂度 构建图：遍历所有的先修课程关系，时间复杂度为 O(E)，其中 E 是先修课程的数量 拓扑排序：每门课程和它的邻接课程都最多被访问一次，时间复杂度为 O(V)，其中 V 是课程数 总时间复杂度 O(E + V)\n空间复杂度 图邻接表 g 占用 O(E) 空间 入度数组 d 占用 O(V) 空间。 队列 q 的最大空间占用为 O(V) 空间复杂度为 O(E + V)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: bool canFinish(int numCourses, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; prerequisites) { // 1. 构建图和入度数组 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; g(numCourses); // 邻接表 std::vector\u0026lt;int\u0026gt; d(numCourses); // 入度数组 for (std::vector\u0026lt;int\u0026gt;\u0026amp; pre : prerequisites) { g[pre[1]].push_back(pre[0]); // 构建图：b -\u0026gt; a ++d[pre[0]]; // 课程 a 的入度加 1 } // 2. 初始化队列 std::queue\u0026lt;int\u0026gt; q; for (int i = 0; i \u0026lt; numCourses; ++i) { if (d[i] == 0) // 入度为 0 的课程入队 q.push(i); } // 3. 拓扑排序 int res = 0; // 记录完成课程数量 while (!q.empty()) { ++res; // 每完成一门课程，计数加 1 int i = q.front(); q.pop(); for (int j : g[i]) { // 遍历当前课程的后续课程 if (--d[j] == 0) // 后续课程入度减 1 q.push(j); // 如果入度变为 0，加入队列 } } // 4. 判断结果 return res == numCourses; // 如果完成课程数等于总课程数，返回 true } }; ","date":"2024-12-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/course-schedule/","title":"Course Schedule"},{"content":"208. 实现Trie树 分析 定义 Trie 树的节点结构 每个节点包含以下信息： is_end：标志当前节点是否是某个单词的结束节点 son[26]：一个数组，用于存储指向 26 个小写英文字母子节点的指针。如果某个字母子节点不存在，则为 nullptr 初始化 Trie 树 构造函数中初始化根节点 root 插入单词 insert() 从根节点出发，逐字符检查单词： 如果当前字符对应的子节点不存在，则创建新节点 移动到对应的子节点。 最后将当前节点标记为结束节点 is_end = true 搜索单词 search() 从根节点出发，逐字符遍历单词： 如果某字符对应的子节点不存在，返回 false 如果全部字符都匹配且最后节点是结束节点，返回 true 否则，返回 false 检查前缀 startsWith() 与 search 类似，但不需要检查是否是结束节点。只要能完整遍历到前缀，返回 true；否则返回 false 时间复杂度 insert()：O(n)，其中 n 是单词长度，每次需要逐字符插入 search()：O(n)，需要逐字符查找 startsWith()：O(n)，需要逐字符查找 空间复杂度 每个节点存储 26 个指针，整体空间复杂度取决于插入的单词集合的总字符数\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class Trie { public: // 定义 Trie 树节点类型 struct Node { Node() { is_end = false; for (int i = 0; i \u0026lt; 26; ++i) son[i] = nullptr; } bool is_end; // 当前节点是否是某个单词的结束 Node* son[26]; // 指向 26 个子节点的指针数组 }; Node* root; // Trie 树的根节点 Trie() { root = new Node(); // 初始化根节点 } // 插入单词 void insert(string word) { Node* p = root; for (char c : word) { int u = c - \u0026#39;a\u0026#39;; // 计算字符对应的子节点索引 if (!p-\u0026gt;son[u]) // 如果不存在该子节点，则创建新节点 p-\u0026gt;son[u] = new Node(); p = p-\u0026gt;son[u]; // 移动到子节点 } p-\u0026gt;is_end = true; // 标记单词结束 } // 搜索单词 bool search(string word) { Node* p = root; for (char c : word) { int u = c - \u0026#39;a\u0026#39;; // 计算字符对应的子节点索引 if (!p-\u0026gt;son[u]) // 如果子节点不存在，返回 false return false; p = p-\u0026gt;son[u]; // 移动到子节点 } return p-\u0026gt;is_end; // 如果最后是结束节点，返回 true } // 检查前缀 bool startsWith(string prefix) { Node* p = root; for (char c : prefix) { int u = c - \u0026#39;a\u0026#39;; // 计算字符对应的子节点索引 if (!p-\u0026gt;son[u]) // 如果子节点不存在，返回 false return false; p = p-\u0026gt;son[u]; // 移动到子节点 } return true; // 如果能遍历完整前缀，返回 true } }; ","date":"2024-12-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/implement-trie-prefix-tree/","title":"Implement Trie Prefix Tree"},{"content":"200. 岛屿数量 分析 岛屿的定义 '1' 表示陆地，'0' 表示水 一个岛屿是由相邻（水平或垂直方向）的 '1' 连续组成的一块区域 遍历网格 遍历网格中每个位置 (i, j)，若当前位置为 '1'，说明发现了一个新的岛屿： 执行深度优先搜索 dfs() 标记当前岛屿的所有陆地为 '*'，表示已访问 岛屿数量加 1 深度优先搜索dfs() 从当前陆地 (x, y) 出发，尝试向四个方向移动（上、下、左、右） 若移动后的位置仍为 '1' 且未越界，递归调用 dfs() 继续标记 时间复杂度 每个格子最多被访问一次，时间复杂度为 O(m * n)，其中 m 和 n 分别是网格的行数和列数\n空间复杂度 递归栈深度取决于岛屿的最大面积，最坏情况下为 O(m * n)，即岛屿覆盖整个网格\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;char\u0026gt;\u0026gt; g; // 全局保存网格 int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0}; // 四个方向 int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { g = grid; // 初始化网格 int res = 0; // 岛屿数量 for (int i = 0; i \u0026lt; g.size(); ++i) for (int j = 0; j \u0026lt; g[0].size(); ++j) if (g[i][j] == \u0026#39;1\u0026#39;) // 找到未访问的陆地 { dfs(i, j); // 标记整个岛屿 ++res; // 岛屿数量加 1 } return res; } void dfs(int x, int y) { g[x][y] = \u0026#39;*\u0026#39;; // 标记当前位置为已访问 for (int i = 0; i \u0026lt; 4; ++i) // 尝试向四个方向移动 { int a = x + dx[i], b = y + dy[i]; if (a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; g.size() \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; g[0].size() \u0026amp;\u0026amp; g[a][b] == \u0026#39;1\u0026#39;) dfs(a, b); // 若新位置是未访问的陆地，递归处理 } } }; ","date":"2024-12-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/number-of-islands/","title":"Number of Islands"},{"content":"994. 腐烂的橘子 分析 初始状态 遍历整个网格 grid，找到所有腐烂橘子（值为 2），并将其坐标加入队列 q 中 初始化时间计数器 res 为 -1，表示腐烂传播的分钟数 广度优先搜索BFS扩散 使用 BFS 模拟腐烂橘子的扩散过程，每次遍历队列中的腐烂橘子，将其四周的相邻新鲜橘子（值为 1）腐烂，并将新腐烂的橘子加入队列 每完成一次队列的扩散操作，时间计数器 res 加 1 检查剩余新鲜橘子 遍历网格，若仍存在新鲜橘子（值为 1），返回 -1 否则返回 res，表示所有橘子腐烂所需的最小分钟数 时间复杂度 遍历网格：初始状态下遍历所有单元格 O(n * m) BFS 扩散：每个橘子最多入队一次，时间复杂度为 O(n * m) 总时间复杂度 O(n * m)\n空间复杂度 队列：队列中存储橘子的坐标，最多为 O(m * n) 总空间复杂度：O(m * n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class Solution { public: int orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { using PII = std::pair\u0026lt;int, int\u0026gt;; std::queue\u0026lt;PII\u0026gt; q; int n = grid.size(), m = grid[0].size(); // 将所有初始腐烂橘子的坐标加入队列 for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; m; ++j) if (grid[i][j] == 2) q.push({i, j}); int res = 0; if (!q.empty()) --res; // 队列非空，初始化分钟数为 -1 int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0}; // BFS 扩散腐烂 while (!q.empty()) { ++res; // 每遍历一层队列，时间加 1 int len = q.size(); while (len--) { PII tmp = q.front(); q.pop(); int x = tmp.first, y = tmp.second; // 遍历四个方向 for (int i = 0; i \u0026lt; 4; ++i) { int a = x + dx[i], b = y + dy[i]; if (a \u0026lt; 0 || a \u0026gt;= n || b \u0026lt; 0 || b \u0026gt;= m || grid[a][b] != 1) continue; q.push({a, b}); // 加入新腐烂的橘子 grid[a][b] = 2; // 标记为腐烂 } } } // 检查是否有剩余新鲜橘子 for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; m; ++j) if (grid[i][j] == 1) return -1; // 仍有新鲜橘子，返回 -1 return res; // 返回所需的分钟数 } }; ","date":"2024-12-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/rotting-oranges/","title":"Rotting Oranges"},{"content":"98. 验证二叉搜索树 分析 二叉搜索树的性质 对于任意节点，其左子树所有节点值均小于该节点值，右子树所有节点值均大于该节点值 递归验证子树 每次检查当前节点是否满足范围条件 [l, r] 如果当前节点值小于等于 l 或大于等于 r，直接返回 false 对左子树递归验证，更新上界为当前节点值 对右子树递归验证，更新下界为当前节点值 递归终止条件 当节点为 nullptr 时，返回 true，表示空子树有效 时间复杂度 每个节点只访问一次，时间复杂度为 O(n)，其中 n 为节点数\n空间复杂度 递归深度由树的高度决定，空间复杂度为 O(h)，其中 h 为树的高度\n最坏情况：链式结构，O(n) 最好情况：平衡二叉树，O(logn) C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: bool isValidBST(TreeNode* root) { // 初始范围设为 LONG_MIN 到 LONG_MAX return dfs(root, LONG_MIN, LONG_MAX); } bool dfs(TreeNode* root, long l, long r) { if (!root) return true; // 空节点为有效子树 // 检查当前节点值是否在合法范围内 if (l \u0026gt;= root-\u0026gt;val || r \u0026lt;= root-\u0026gt;val) return false; // 递归检查左子树和右子树 return dfs(root-\u0026gt;left, l, root-\u0026gt;val) \u0026amp;\u0026amp; dfs(root-\u0026gt;right, root-\u0026gt;val, r); } }; ","date":"2024-12-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/validate-binary-search-tree/","title":"Validate Binary Search Tree"},{"content":"108. 将有序数组转换为二叉搜索树 分析 确定递归终止条件\n如果当前范围内左边界 l 大于右边界 r，返回 nullptr，表示没有节点 递归构造子树\n找到当前范围的中点 mid，该点的值作为当前子树的根节点 递归调用构建左子树，范围为 [l, mid - 1] 递归调用构建右子树，范围为 [mid + 1, r] 返回构造的根节点\n根据中点值创建一个新的节点，连接左子树和右子树，返回该节点作为当前子树的根节点 时间复杂度 递归次数：每次递归划分数组为两半，总体复杂度为 O(logn) 层 每层处理复杂度：每层需要处理数组范围，整体为 O(n) 总时间复杂度 O(n)\n空间复杂度 递归栈空间：递归深度为 O(logn)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: TreeNode* sortedArrayToBST(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // 调用递归函数构建平衡二叉搜索树 return build(nums, 0, nums.size() - 1); } TreeNode* build(std::vector\u0026lt;int\u0026gt;\u0026amp; nums, int l, int r) { if (l \u0026gt; r) return nullptr; // 递归终止条件：无效范围 int mid = (l + r) \u0026gt;\u0026gt; 1; // 找到当前范围的中点 TreeNode* root = new TreeNode(nums[mid]); // 创建根节点 root-\u0026gt;left = build(nums, l, mid - 1); // 构建左子树 root-\u0026gt;right = build(nums, mid + 1, r); // 构建右子树 return root; // 返回根节点 } }; ","date":"2024-12-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/convert-sorted-array-to-binary-search-tree/","title":"Convert Sorted Array to Binary Search Tree"},{"content":"543. 二叉树的直径 分析 主函数 diameterOfBinaryTree\n初始化全局变量 res，用来存储最大直径 调用辅助函数 dfs，从根节点开始递归计算深度和路径长度 返回 res 辅助函数 dfs\n基本情况：如果当前节点为空，返回深度为 0 递归计算左右子树深度：分别调用 dfs(root-\u0026gt;left) 和 dfs(root-\u0026gt;right) 更新直径： 当前节点的路径长度为 left + right 更新 res 为 max(res, left + right) 返回节点深度：节点的深度是其左右子树深度的最大值加 1 时间复杂度 时间复杂度 O(n)，其中 n 是节点总数，每个节点访问一次\n空间复杂度 空间复杂度 O(h)，其中 h 是树的高度，递归栈的深度\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public: int res = 0; // 保存树的最大直径 int diameterOfBinaryTree(TreeNode* root) { // 调用辅助函数计算直径 dfs(root); return res; } int dfs(TreeNode* root) { // 如果节点为空，返回深度为 0 if (!root) return 0; // 递归计算左右子树的深度 int left = dfs(root-\u0026gt;left); int right = dfs(root-\u0026gt;right); // 更新最大直径：当前节点的左子树深度 + 右子树深度 res = std::max(res, left + right); // 返回当前节点的深度 return std::max(left, right) + 1; } }; ","date":"2024-12-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/diameter-of-binary-tree/","title":"Diameter of Binary Tree"},{"content":"226. 翻转二叉树 分析 递归结束条件 如果当前节点 root 为 nullptr，直接返回 nullptr，表示已到达叶子节点的空子树 交换左右子树 使用 std::swap 交换当前节点的左子树和右子树 递归处理子树 对交换后的左子树调用 invertTree 对交换后的右子树调用 invertTree 返回结果 当所有节点都完成翻转后，返回根节点 root 时间复杂度 每个节点被访问一次，执行左右子树的交换操作，因此时间复杂度为 O(n)，其中 n 是节点总数\n空间复杂度 递归调用的栈深度取决于树的高度。在最坏情况下（单链表形式的树），空间复杂度为 O(n)；在最优情况下（完全平衡二叉树），空间复杂度为 O(logn)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // DFS class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return nullptr; // 若节点为空，直接返回 std::swap(root-\u0026gt;left, root-\u0026gt;right); // 交换左右子树 invertTree(root-\u0026gt;left); // 递归处理左子树 invertTree(root-\u0026gt;right); // 递归处理右子树 return root; // 返回翻转后的树根节点 } }; // BFS class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return nullptr; std::queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); // 将根节点入队 while (!q.empty()) { TreeNode* node = q.front(); q.pop(); // 交换左右子树 std::swap(node-\u0026gt;left, node-\u0026gt;right); // 将子节点入队 if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } return root; } }; ","date":"2024-12-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/invert-binary-tree/","title":"Invert Binary Tree"},{"content":"101. 对称二叉树 分析 主函数 isSymmetric\n首先检查根节点是否为空。如果根节点为空，则树是对称的，返回 true 调用辅助函数 dfs，传入根节点的左右子树进行判断 辅助函数 dfs\n判断当前两个节点： 如果两者都为空，返回 true 如果只有一个为空或节点值不同，返回 false 递归调用 dfs： 比较左子树的左孩子和右子树的右孩子是否对称 比较左子树的右孩子和右子树的左孩子是否对称 时间复杂度 时间复杂度 O(n)，n 为节点数，每个节点访问一次\n空间复杂度 空间复杂度 O(h)，h 为树的高度，递归栈的深度\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public: bool isSymmetric(TreeNode* root) { // 如果根节点为空，直接返回 true if (!root) return true; // 调用辅助函数判断左右子树是否对称 return dfs(root-\u0026gt;left, root-\u0026gt;right); } bool dfs(TreeNode* left, TreeNode* right) { // 如果两个子树都为空，说明对称 if (!left \u0026amp;\u0026amp; !right) return true; // 如果只有一个子树为空，或两子树值不等，不对称 if (!left || !right || left-\u0026gt;val != right-\u0026gt;val) return false; // 递归检查：左子树的左孩子和右子树的右孩子是否对称 // 以及左子树的右孩子和右子树的左孩子是否对称 return dfs(left-\u0026gt;left, right-\u0026gt;right) \u0026amp;\u0026amp; dfs(left-\u0026gt;right, right-\u0026gt;left); } }; ","date":"2024-12-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/is-symmetric/","title":"Is Symmetric"},{"content":"102. 二叉树的层序遍历 分析 初始化结果数组 res 和队列 q 若 root 为空，直接返回空的 res 将根节点加入队列，进入循环： 获取当前层节点数量 len 遍历当前层的所有节点： 弹出队头节点，加入当前层结果数组 level 将该节点的左右子节点（若存在）加入队列 将当前层的结果 level 加入到 res 中 时间复杂度 时间复杂度 O(n)，其中 n 是二叉树的节点总数。每个节点都会被访问一次\n空间复杂度 空间复杂度 O(m)，其中 m 是二叉树的最大宽度。队列在最宽的层存储所有节点\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { // 存储最终结果 std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; if (!root) return res; // 特殊情况：空树 // 初始化队列 std::queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); // 遍历每一层 while (!q.empty()) { int len = q.size(); // 当前层节点数 std::vector\u0026lt;int\u0026gt; level; // 存储当前层的节点值 // 遍历当前层的节点 while (len--) { TreeNode* node = q.front(); q.pop(); level.push_back(node-\u0026gt;val); // 将节点值加入当前层结果 if (node-\u0026gt;left) q.push(node-\u0026gt;left); // 加入左子节点 if (node-\u0026gt;right) q.push(node-\u0026gt;right); // 加入右子节点 } res.push_back(level); // 将当前层结果加入到最终结果 } return res; // 返回层序遍历结果 } }; ","date":"2024-12-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/level-order/","title":"Level Order"},{"content":"94. 二叉树的中序遍历 分析 中序遍历的顺序是：左子树 -\u0026gt; 根节点 -\u0026gt; 右子树\n初始化数据结构\n创建一个结果数组 res，用于存储中序遍历的结果 创建一个栈 stk，用于辅助遍历 模拟递归过程\n向左下方向遍历：当前节点非空时，将当前节点压入栈，并将其移动到左子节点\n回溯节点并访问右子树：如果当前节点为空（即到达左子树的最深处），从栈中弹出一个节点，访问该节点的值并存入结果数组，然后将当前节点移动到其右子节点\n重复以上过程，直到栈为空且当前节点为空\n时间复杂度 每个节点被访问两次（一次压入栈，一次弹出栈），因此时间复杂度为 O(n)，其中 n 是节点总数\n空间复杂度 栈的深度取决于树的高度。在最坏情况下（如链状树），栈的空间复杂度为 O(n)；在平衡树中，栈的空间复杂度为 O(logn)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 // 非递归 class Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { std::vector\u0026lt;int\u0026gt; res; // 存储中序遍历结果 std::stack\u0026lt;TreeNode*\u0026gt; stk; // 辅助栈 while (root || !stk.empty()) // 当节点非空或栈非空时，继续遍历 { // 一直向左走，将路径上的节点压入栈 while (root) { stk.push(root); // 压入栈 root = root-\u0026gt;left; // 移动到左子节点 } // 回溯：弹出栈顶节点 root = stk.top(); stk.pop(); res.push_back(root-\u0026gt;val); // 访问节点值 root = root-\u0026gt;right; // 转向右子树 } return res; // 返回结果 } }; // 递归 class Solution { public: std::vector\u0026lt;int\u0026gt; res; void dfs(TreeNode* root) { if (!root) return; dfs(root-\u0026gt;left); res.push_back(root-\u0026gt;val); dfs(root-\u0026gt;right); } vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { dfs(root); return res; } }; ","date":"2024-12-01T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/binary-tree-inorder-traversal/","title":"Binary Tree inorder Traversal"},{"content":"104. 二叉树的最大深度 分析 初始化\n创建一个变量 res，初始化为 0，用于记录树的最大深度 创建一个队列 q，用于辅助层序遍历 处理根节点\n如果根节点 root 不为空，将其加入队列 层序遍历\n每次从队列中取出当前层的所有节点（根据队列长度决定） 遍历当前层的节点，依次将每个节点的左右子节点加入队列 每处理完一层后，将深度变量 res 增加 1 返回结果\n当队列为空时，树的所有层已遍历完，返回变量 res，即为最大深度 时间复杂度 每个节点被访问一次，因此时间复杂度为 O(n)，其中 n 是节点总数\n空间复杂度 队列的最大空间取决于某一层的最大节点数。在完全二叉树的情况下，最大节点数可能是 n/2，因此空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // BFS class Solution { public: int maxDepth(TreeNode* root) { int res = 0; // 初始化深度为 0 std::queue\u0026lt;TreeNode*\u0026gt; q; // 辅助队列，用于层序遍历 if (root) q.push(root); // 如果根节点非空，加入队列 while (!q.empty()) // 队列非空时，继续遍历 { int len = q.size(); // 当前层的节点数量 // 遍历当前层的所有节点 while (len--) { TreeNode* node = q.front(); // 获取队首节点 q.pop(); // 弹出队首节点 // 将当前节点的左右子节点加入队列 if (node-\u0026gt;left) q.push(node-\u0026gt;left); if (node-\u0026gt;right) q.push(node-\u0026gt;right); } ++res; // 每完成一层，深度加 1 } return res; // 返回最大深度 } }; // DFS class Solution { public: int maxDepth(TreeNode* root) { if (!root) return 0; return std::max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)) + 1; } }; ","date":"2024-12-01T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maximum-depth-of-binary-tree/","title":"Maximum Depth of Binary Tree"},{"content":"148. 排序链表 分析 计算链表长度 遍历链表，统计节点数量 n，以确定归并的步长范围 自底向上归并排序 按步长 i 从小到大逐步归并，初始步长为 1，逐渐乘以 2，直到覆盖整个链表 每次归并时，将链表分成两部分，每部分包含 i 个节点，然后对这两部分进行归并 最后将归并的结果重新连接到链表中 归并两个子链表 使用两个指针分别指向两个子链表的头部，逐一比较节点的值，将较小值的节点加入到排序后的链表中，直到处理完两部分中的所有节点 更新链表 经过多轮归并后，最终的链表即为排序后的链表 时间复杂度 每轮归并的时间复杂度为 O(n)，需要进行 log(n) 轮归并，因此总复杂度为 O(nlogn)\n空间复杂度 采用自底向上归并，不需要额外空间，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class Solution { public: ListNode* sortList(ListNode* head) { // 第 1 步：计算链表长度 int n = 0; for (ListNode* p = head; p; p = p-\u0026gt;next) ++n; // 第 2 步：归并排序 for (int i = 1; i \u0026lt; n; i *= 2) { ListNode* dummy = new ListNode(-1); // 虚拟头节点 ListNode* cur = dummy; for (int j = 1; j \u0026lt;= n; j += i * 2) { // 划分两段链表 ListNode *p = head, *q = p; for (int k = 0; k \u0026lt; i \u0026amp;\u0026amp; q; ++k) q = q-\u0026gt;next; // 第二段起点 ListNode* o = q; for (int k = 0; k \u0026lt; i \u0026amp;\u0026amp; o; ++k) o = o-\u0026gt;next; // 下一部分的起点 // 归并两段链表 int l = 0, r = 0; while (l \u0026lt; i \u0026amp;\u0026amp; r \u0026lt; i \u0026amp;\u0026amp; p \u0026amp;\u0026amp; q) { if (p-\u0026gt;val \u0026lt;= q-\u0026gt;val) { cur-\u0026gt;next = p; p = p-\u0026gt;next; ++l; } else { cur-\u0026gt;next = q; q = q-\u0026gt;next; ++r; } cur = cur-\u0026gt;next; } // 剩余部分处理 while (l \u0026lt; i \u0026amp;\u0026amp; p) { cur = cur-\u0026gt;next = p; p = p-\u0026gt;next; ++l; } while (r \u0026lt; i \u0026amp;\u0026amp; q) { cur = cur-\u0026gt;next = q; q = q-\u0026gt;next; ++r; } // 更新链表头 head = o; } cur-\u0026gt;next = nullptr; head = dummy-\u0026gt;next; // 更新链表头为新的排序结果 } return head; } }; ","date":"2024-12-01T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/sort-list/","title":"Sort List"},{"content":"2. 两数相加 分析 初始化 使用一个虚拟头节点 dummy，方便操作结果链表 用指针 cur 指向结果链表的当前尾部 定义一个变量 sum 用于存储当前位的加和（包括进位） 逐位相加 遍历链表 l1 和 l2，对每一位的值进行相加，同时加上进位 sum 取个位数字作为当前位的值，新建节点添加到结果链表中 更新 sum 为十位上的进位。 处理进位 当 l1 和 l2 遍历完后，如果还有进位 sum \u0026gt; 0，需要额外创建一个节点存储进位 时间复杂度 时间复杂度 O(max(n, m))，n 和 m 分别为链表 l1 和 l2 的长度，需要遍历两链表的所有节点\n空间复杂度 空间复杂度为 O(max(n, m))\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { int sum = 0; // 用于存储每个位的和以及进位 ListNode* dummy = new ListNode(-1); // 虚拟头节点 ListNode* cur = dummy; // 指向结果链表的当前尾部 // 遍历链表 l1 和 l2 while (l1 || l2 || sum) { // 如果 l1 或 l2 不为空，加上它们当前位的值 if (l1) { sum += l1-\u0026gt;val; l1 = l1-\u0026gt;next; // 移动到下一位 } if (l2) { sum += l2-\u0026gt;val; l2 = l2-\u0026gt;next; // 移动到下一位 } // 创建新节点存储当前位的值，并连接到结果链表 cur = cur-\u0026gt;next = new ListNode(sum % 10); // 更新进位 sum /= 10; } // 返回结果链表 return dummy-\u0026gt;next; } }; ","date":"2024-11-30T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/add-two-numbers/","title":"Add Two Numbers"},{"content":"138. 随机链表的复制 分析 在原链表中插入新节点 遍历原链表，对于每个节点 p，创建一个新节点 q 将新节点插入到原节点 p 和 p-\u0026gt;next 之间，形成交错链表结构：原节点 -\u0026gt; 新节点 -\u0026gt; 原节点 复制 random 指针 再次遍历交错链表，对于每个原节点 p，将 p-\u0026gt;next-\u0026gt;random 设置为 p-\u0026gt;random-\u0026gt;next，即新节点的 random 指向对应的新节点 拆分链表 遍历交错链表，将新节点从中分离出来，形成深拷贝链表，同时还原原链表的结构 时间复杂 遍历链表三次，分别处理插入节点、复制 random 指针、拆分链表，时间复杂度 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: Node* copyRandomList(Node* head) { // 第 1 步：在原链表中插入新节点 for (Node* p = head; p; p = p-\u0026gt;next-\u0026gt;next) { Node* q = new Node(p-\u0026gt;val); // 创建新节点 q-\u0026gt;next = p-\u0026gt;next; // 插入新节点到原节点之后 p-\u0026gt;next = q; } // 第 2 步：复制 random 指针 for (Node* p = head; p; p = p-\u0026gt;next-\u0026gt;next) { if (p-\u0026gt;random) p-\u0026gt;next-\u0026gt;random = p-\u0026gt;random-\u0026gt;next; // 设置新节点的 random } // 第 3 步：拆分链表 Node* dummy = new Node(-1); // 虚拟头节点 Node* cur = dummy; for (Node* p = head; p; p = p-\u0026gt;next) { Node* q = p-\u0026gt;next; // 取出新节点 cur = cur-\u0026gt;next = q; // 将新节点连接到深拷贝链表 p-\u0026gt;next = q-\u0026gt;next; // 恢复原链表结构 } return dummy-\u0026gt;next; } }; ","date":"2024-11-30T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/copy-list-with-random-pointer/","title":"Copy List with Random Pointer"},{"content":"141. 环形链表 分析 初始化指针\n如果链表为空或只有一个节点，则无法形成环，直接返回 false 设置两个指针 slow 和 fast，初始时都指向链表的头节点 head 移动指针\n慢指针 slow 每次移动一步 快指针 fast 每次移动两步 每次移动后，检查 slow 和 fast 是否相等。如果相等，说明链表中存在环 终止条件\n如果 fast 为 nullptr，说明链表没有环，直接返回 false 时间复杂度 慢指针最多遍历链表一次，快指针最多遍历链表两次，因此时间复杂度为 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: bool hasCycle(ListNode *head) { // 链表为空或只有一个节点，无法形成环 if (!head || !head-\u0026gt;next) return false; ListNode *slow = head, *fast = head; while (fast) // 快指针未到达链表末尾 { slow = slow-\u0026gt;next; // 慢指针走一步 fast = fast-\u0026gt;next; // 快指针走一步 if (fast) fast = fast-\u0026gt;next; // 快指针再走一步 if (slow == fast) // 快慢指针相遇，存在环 return true; } return false; // 快指针到达链表末尾，无环 } }; ","date":"2024-11-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/linkedlistcycle/","title":"linkedListCycle"},{"content":"142. 环形链表II 分析 判断链表是否有环\n设置两个指针 slow 和 fast，初始都指向链表头节点 head 快指针每次移动两步，慢指针每次移动一步 如果快指针追上慢指针，说明链表中有环；否则，如果快指针或其下一节点为空，则链表无环 找到环的起始节点\n当快慢指针相遇时，将慢指针重置为链表头节点 head 快指针保持在相遇位置 两个指针每次都向前移动一步，当两者再次相遇时，相遇点即为环的起始节点 数学推导 假设：\n链表头到环入口节点的距离为 a 环入口到相遇点的距离为 b 相遇点到环入口的距离为 c 快指针比慢指针速度快一倍，因此：2(a + b) = a + b + n(b + c)（ n 为快指针在环中绕的圈数），化简得：a = c + (n - 1)(b + c) 这表明：\n从链表头节点到环入口的距离 a 等于从相遇点沿环走回入口的距离 c 因此，当两个指针一个从链表头开始，一个从相遇点开始，每次移动一步，最终会在环的起始节点相遇 时间复杂度 快慢指针遍历链表一次即可确定是否有环，以及找到环的起始节点，时间复杂度 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: ListNode *detectCycle(ListNode *head) { // 链表为空或只有一个节点，不可能有环 if (!head || !head-\u0026gt;next) return nullptr; ListNode *slow = head, *fast = head; // 判断链表是否有环 while (fast) { slow = slow-\u0026gt;next; // 慢指针走一步 fast = fast-\u0026gt;next; // 快指针走一步 if (fast) fast = fast-\u0026gt;next; // 快指针再走一步 if (slow == fast) // 快慢指针相遇 { // 找到环的起始节点 slow = head; // 慢指针回到链表头 while (slow != fast) // 两指针相遇即为环入口 { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next; } return fast; } } return nullptr; // 无环 } }; ","date":"2024-11-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/linkedlistcycleii/","title":"linkedListCycleII"},{"content":"234. 回文链表 分析 计算链表长度\n遍历链表一次，统计节点总数 len。用于确定需要存入栈的节点数量 存储前半部分元素到栈中\n再次遍历链表，将前半部分的节点值压入栈中。如果链表长度为奇数，则跳过中间节点（因为中间节点不影响回文判断） 比较后半部分的值\n从链表中间位置开始继续遍历链表，每遇到一个节点，就弹出栈顶的元素，与当前节点值比较。如果有任意不相等的情况，说明链表不是回文链表 判断结果\n遍历完后，若所有值都匹配，则链表是回文的，返回 true 时间复杂度 时间复杂度 O(n)\n空间复杂度 空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public: bool isPalindrome(ListNode* head) { // 求链表长度 int len = 0; for (ListNode* p = head; p; p = p-\u0026gt;next) ++len; // 用栈存储前半部分节点值 ListNode* p = head; std::stack\u0026lt;int\u0026gt; stk; for (int i = 0; i \u0026lt; len / 2; ++i) { stk.push(p-\u0026gt;val); p = p-\u0026gt;next; } // 如果链表长度为奇数，跳过中间节点 if (len % 2 == 1) p = p-\u0026gt;next; // 比较后半部分节点值与栈中元素 while (p) { if (stk.top() != p-\u0026gt;val) return false; stk.pop(); p = p-\u0026gt;next; } return true; } }; ","date":"2024-11-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/palindromelinkedlist/","title":"palindromeLinkedList"},{"content":"206. 反转链表 分析 初始化指针\n定义一个指针 prev，初始值为 nullptr，用于指向反转后链表的头节点 定义一个指针 cur，初始指向链表的头节点 head，用于遍历链表 遍历链表\n在遍历的每一步，保存当前节点的下一节点 next 调整当前节点 cur 的 next 指针，使其指向 prev，实现反转 将 prev 更新为当前节点 cur，将 cur 更新为 next 终止条件\n当 cur 遍历到链表末尾（即为 nullptr ）时，链表已经完全反转，此时 prev 指针指向反转后的链表头节点 时间复杂度 时间复杂度 O(n)，其中 n 为链表的长度。每个节点访问一次\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; // 初始化反转链表的头节点为 nullptr ListNode* cur = head; // 从链表头节点开始遍历 while (cur) // 遍历整个链表 { ListNode* next = cur-\u0026gt;next; // 保存当前节点的下一节点 cur-\u0026gt;next = prev; // 将当前节点的 next 指向反转链表的头 prev = cur; // 更新 prev 为当前节点 cur = next; // 继续遍历下一个节点 } return prev; // 返回反转后的链表头节点 } }; ","date":"2024-11-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reverselinkedlist/","title":"reverseLinkedList"},{"content":"160. 相交链表 分析 初始化指针\n定义两个指针 p 和 q，分别指向链表 headA 和 headB 的头节点 遍历链表\n让两个指针同时遍历各自的链表，当某个指针到达链表尾部时，切换到另一个链表的头节点继续遍历 终止条件\n如果链表相交，p 和 q 会在相交节点相遇，此时返回相交节点 如果链表不相交，两个指针会同时变为 null，退出循环并返回 null 关键点\n当一个指针遍历完自己的链表后，切换到另一个链表，从而保证两个指针在第二次遍历时长度相同 这样，当两链表有相交节点时，两个指针在第二次遍历中必定会在相交节点处相遇 时间复杂度 指针最多遍历两个链表一次，两个链表的长度分别为 m 和 n，总时间复杂度 O(m + n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode *p = headA, *q = headB; // 初始化两个指针 p 和 q while (p != q) // 当 p 和 q 不相等时继续循环 { p = p ? p-\u0026gt;next : headB; // 如果 p 非空，移动到下一个节点，否则切换到 headB q = q ? q-\u0026gt;next : headA; // 如果 q 非空，移动到下一个节点，否则切换到 headA } return p; // 返回相交节点或 null } }; ","date":"2024-11-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/intersectionoftwolinkedlists/","title":"intersectionOfTwoLinkedLists"},{"content":"48. 旋转图像 分析 转置矩阵： 遍历上三角区域 (i, j) ，交换每对对称元素 matrix[i][j] 和 matrix[j][i] 水平翻转矩阵： 遍历每一行，交换每行左右两端对称的元素 时间复杂度 转置矩阵需要 O(n^2) 水平翻转需要 O(n^2) 总时间复杂度 O(n^2)\n空间复杂度 在原地修改矩阵，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); // 1. 转置矩阵 for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; i; ++j) std::swap(matrix[i][j], matrix[j][i]); // 2. 水平翻转矩阵 for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; n / 2; ++j) std::swap(matrix[i][j], matrix[i][n - 1 - j]); } }; ","date":"2024-11-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/rotateimage/","title":"rotateImage"},{"content":"74. 搜索二维矩阵 分析 由于矩阵按行列有序，可以将整个二维矩阵视为一个长度为 n * m 的一维数组，并在这个一维数组上进行二分查找\n矩阵映射为一维数组：\n矩阵的第 i 行和第 j 列的元素 matrix[i][j]，在一维数组中对应的索引为 i * m + j 反之，一维数组的索引 k 对应矩阵中的元素为 matrix[k / m][k % m] 二分查找：\n初始时，定义查找区间的左右端点为 l = 0 和 r = m * n - 1 每次取中点 mid，将其映射到二维矩阵元素 matrix[mid / m][mid % m] ，与 target 比较： 若该值大于等于 target，收缩右边界 r = mid 若该值小于 target，收缩左边界 l = mid + 1 循环结束时，检查索引 r 对应的矩阵元素是否等于 target 时间复杂度 每次二分查找都会将查找范围缩小为原来的一半，总体复杂度为 O(log(m * n))\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int n = matrix.size(), m = matrix[0].size(); // 矩阵行数和列数 int l = 0, r = n * m - 1; // 二分区间 [l, r] while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; // 中点 if (target \u0026lt;= matrix[mid / m][mid % m]) r = mid; // 收缩右边界 else l = mid + 1; // 收缩左边界 } // 判断最终位置是否是目标值 return matrix[r / m][r % m] == target; } }; ","date":"2024-11-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/search2dmatrix/","title":"search2dMatrix"},{"content":"240. 搜索二维矩阵II 分析 利用矩阵的排序特性，可以从矩阵的右上角（或左下角）开始搜索：\n选择右上角 (0, m - 1) 为起点： 如果当前位置的值等于目标值，返回 true 如果当前位置的值小于目标值，则向下移动一行（增加行索引） 如果当前位置的值大于目标值，则向左移动一列（减少列索引） 退出条件： 如果行索引越界 x \u0026gt; n 或列索引越界 y \u0026lt; 0，说明矩阵中没有目标值，返回 false 时间复杂度 每次移动都会排除当前行或列的一部分，最多移动 m + n 次，因此时间复杂度为 O(m + n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int n = matrix.size(), m = matrix[0].size(); if (n == 0 || m == 0) return false; int x = 0, y = m - 1; // 从右上角开始 while (x \u0026lt; n \u0026amp;\u0026amp; y \u0026gt;= 0) { if (matrix[x][y] == target) return true; // 找到目标值 else if (matrix[x][y] \u0026lt; target) ++ x; // 目标值更大，向下移动 else -- y; // 目标值更小，向左移动 } return false; // 未找到目标值 } }; ","date":"2024-11-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/search2dmatrixii/","title":"search2dMatrixII"},{"content":"54. 螺旋矩阵 分析 初始化变量： 使用 count 记录已访问的元素个数，初始为 0 将已访问的元素标记为 INF，以避免重复访问 初始化起始位置为 (x, y) = (0, -1) 按顺时针方向遍历： 按照 右、下、左、上 的顺序依次遍历矩阵 检查下一步是否越界或访问到标记值，如果满足条件则改变方向 收集结果： 在每次遍历过程中，将当前值加入结果数组 res 返回结果： 当遍历的元素数量 count 等于矩阵元素总数时，返回结果 时间复杂度 需要遍历矩阵中的所有元素，总时间复杂度 O(n * m)\n空间复杂度 在矩阵内原地标记访问过的元素，无需额外空间，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); // 矩阵行数 int m = matrix[0].size(); // 矩阵列数 int count = 0; // 记录访问过的元素数量 int INF = 0x3f3f3f3f; // 标记值，用于标记已访问的元素 std::vector\u0026lt;int\u0026gt; res; // 存放结果的数组 int x = 0, y = -1; // 起始位置在矩阵外部 while (count \u0026lt; n * m) { // 向右遍历 while (y + 1 \u0026lt; m \u0026amp;\u0026amp; matrix[x][y + 1] != INF) { res.push_back(matrix[x][y + 1]); // 记录元素 matrix[x][y + 1] = INF; // 标记为已访问 ++ y; // 移动列 ++ count; // 更新已访问数量 } // 向下遍历 while (x + 1 \u0026lt; n \u0026amp;\u0026amp; matrix[x + 1][y] != INF) { res.push_back(matrix[x + 1][y]); matrix[x + 1][y] = INF; ++ x; ++ count; } // 向左遍历 while (y - 1 \u0026gt;= 0 \u0026amp;\u0026amp; matrix[x][y - 1] != INF) { res.push_back(matrix[x][y - 1]); matrix[x][y - 1] = INF; -- y; ++ count; } // 向上遍历 while (x - 1 \u0026gt;= 0 \u0026amp;\u0026amp; matrix[x - 1][y] != INF) { res.push_back(matrix[x - 1][y]); matrix[x - 1][y] = INF; -- x; ++ count; } } return res; } }; ","date":"2024-11-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/spiralmatrix/","title":"spiralMatrix"},{"content":"41. 缺失的第一个正数 分析 原地哈希：\n对于一个长度为 n 的数组，最小的缺失正整数只能在 1 到 n+1 之间 遍历数组，对于每个数字 nums[i]，如果满足条件 1 ≤ nums[i] ≤ n 且 nums[i] != nums[nums[i] - 1]，则将其交换到正确的位置 通过循环交换，可以在原地调整数组顺序 检查缺失：\n调整完成后，遍历数组，检查每个位置是否满足 nums[i] == i + 1 如果存在不满足的位置，则返回 i + 1 如果所有位置都满足，说明数组包含所有 1 到 n 的正整数，缺失的正整数为 n + 1 时间复杂度 每个数字最多只会被交换一次，因此总操作次数为 O(n)\n空间复杂度 原地调整数组，无额外空间开销，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int firstMissingPositive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // 调整数组顺序 for (int i = 0; i \u0026lt; n; ++i) while (nums[i] \u0026gt;= 1 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[i] != nums[nums[i] - 1]) std::swap(nums[i], nums[nums[i] - 1]); // 查找第一个缺失的正整数 for (int i = 0; i \u0026lt; n; ++i) if (nums[i] != i + 1) return i + 1; // 如果所有正整数都在正确位置，返回 n + 1 return n + 1; } }; ","date":"2024-11-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/firstmisspositive/","title":"firstMissPositive"},{"content":"53. 最大子数组和 分析 定义状态：\n用变量 last 表示以当前元素结尾的最大子数组和 用变量 res 表示全局最大子数组和 状态转移方程：\n对于每个元素 num，当前的 last 值可以由以下两种情况决定： 单独包含当前元素：如果此前的 last 为负数，则舍弃 包含当前元素并延续之前的子数组：如果此前的 last 为正数，则将当前元素加入子数组 状态转移方程：last = max(num, last + num) 更新全局最大值：\n在遍历每个元素后，更新全局最大值 res 为：res = max(res, last) 时间复杂度 单次遍历：仅需遍历数组一次，时间复杂度为 O(n)\n空间复杂度 只使用了 res 和 last 两个变量，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = INT_MIN; // 全局最大子数组和 int last = 0; // 当前子数组和 for (int num : nums) { last = std::max(num, last + num); // 动态更新以当前元素结尾的最大子数组和 res = std::max(res, last); // 更新全局最大值 } return res; } }; ","date":"2024-11-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxsubarray/","title":"maxSubArray"},{"content":"238. 除自身以外数组的乘积 分析 前缀积数组 pre： pre[i] 表示 nums[0] 到 nums[i - 1] 的乘积 用于保存当前元素之前所有元素的乘积 后缀积变量 sub： 在第二次遍历时，通过一个变量动态记录从右到左的乘积（即 nums[i + 1] 到 nums[n - 1]的乘积） 每次更新 pre[i] 为 pre[i] * sub（计算结果数组），并更新 sub 时间复杂度 前缀积遍历一次，后缀积遍历一次，总体复杂度为 O(n)\n空间复杂度 使用了一个前缀积数组和一个后缀积变量，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;int\u0026gt; productExceptSelf(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // 初始化前缀积数组 std::vector\u0026lt;int\u0026gt; pre(n, 1); for (int i = 1; i \u0026lt; n; ++ i) pre[i] = pre[i - 1] * nums[i - 1]; // 动态计算后缀积并更新结果 int sub = 1; for (int i = n - 1; i \u0026gt;= 0; -- i) { pre[i] *= sub; sub *= nums[i]; } return pre; } }; ","date":"2024-11-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/productofarrayexceptself/","title":"productOfArrayExceptSelf"},{"content":"189. 轮转数组 分析 确定实际轮转次数： 如果 k 大于数组长度 n，轮转后的结果与 k % n 次轮转相同 因此需要先对 k 取模：k %= n 三次反转法： 整体反转：将整个数组反转，这样后 k 个元素会移动到前面 前部分反转：将前 k 个元素反转，恢复它们的顺序 后部分反转：将剩余的 n-k 个元素反转，恢复它们的顺序 时间复杂度 反转操作：每次反转需要遍历部分数组，整体复杂度为 O(n)\n空间复杂度 原地操作：仅使用常数级别的额外空间，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int n = nums.size(); k %= n; // 计算有效的轮转次数 // 反转整个数组 for (int i = 0; i \u0026lt; n / 2; ++i) std::swap(nums[i], nums[n - 1 - i]); // 反转前 k 个元素 for (int i = 0; i \u0026lt; k / 2; ++i) std::swap(nums[i], nums[k - 1 - i]); // 反转后 n-k 个元素 for (int i = k; i \u0026lt; (n + k) / 2; ++i) std::swap(nums[i], nums[n - 1 - i + k]); } }; ","date":"2024-11-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/rotatearray/","title":"rotateArray"},{"content":"73. 矩阵置零 分析 标记行和列：\n用第一行和第一列作为标记位置 如果矩阵中的元素 matrix[i][j] == 0，则将 matrix[i][0] 和 matrix[0][j] 置为 0 ，分别标记第 i 行和第 j 列需要被置 0 特殊处理首行和首列：\n因为第一行和第一列被用作标记，置 0 的操作可能覆盖原始信息 使用两个额外变量 r 和 c 分别标记首行和首列是否需要置 0 置零操作：\n根据第一列的标记，从第二行开始，将需要置 0 的行的所有元素置为 0 根据第一行的标记，从第二列开始，将需要置 0 的列的所有元素置为 0 处理首行和首列：\n如果 r == 0，将第一行全部置 0 如果 c == 0，将第一列全部置 0 时间复杂度 时间复杂度：O(m * n)\n空间复杂度 使用矩阵本身作为标记，无额外空间开销，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public: void setZeroes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(), m = matrix[0].size(); int r = 1, c = 1; // 标记需要置零的行和列 for (int i = 0; i \u0026lt; n; ++i) for (int j = 0; j \u0026lt; m; ++j) if (matrix[i][j] == 0) { if (i == 0) r = 0; if (j == 0) c = 0; matrix[i][0] = 0; matrix[0][j] = 0; } // 根据标记置零 for (int i = 1; i \u0026lt; n; ++i) if (matrix[i][0] == 0) for (int j = 1; j \u0026lt; m; ++j) matrix[i][j] = 0; for (int j = 1; j \u0026lt; m; ++j) if (matrix[0][j] == 0) for (int i = 1; i \u0026lt; n; ++i) matrix[i][j] = 0; // 处理首行和首列 if (r == 0) for (int j = 0; j \u0026lt; m; ++j) matrix[0][j] = 0; if (c == 0) for (int i = 0; i \u0026lt; n; ++i) matrix[i][0] = 0; } }; ","date":"2024-11-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/setmatrixzeroes/","title":"setMatrixZeroes"},{"content":"438. 找到字符串中所有字母异位词 分析 初始化目标频率表：\n使用哈希表 hash 存储字符串 p 中每个字符的频率 滑动窗口遍历字符串 s：\n窗口初始范围为 [j, i]，窗口长度不超过 p.size() 遍历字符串 s，对窗口内的字符更新哈希表： 窗口右扩（加入字符）： 将当前字符 s[i] 加入窗口，并在 hash 中减少其频率 如果该字符的频率变为 0，说明该字符的频率匹配，增加匹配计数 count 窗口左缩（移除字符）： 如果窗口长度超过 p.size()，将左端字符 s[j] 从窗口移除： 如果 s[j] 在 hash 中频率变为非零，匹配计数 count 减少 更新左指针 j 判断异位词：\n如果窗口内所有字符频率均匹配（count == total），将当前窗口左端索引 j 加入结果集 res 时间复杂度 初始化哈希表：O(p)，其中 p 是字符串 p 的长度 滑动窗口遍历：O(s)，其中 s 是字符串 s 的长度 总时间复杂度：O(s + p)\n空间复杂度 使用了一个哈希表存储字符频率，空间复杂度为 O(k)，其中 k 是字符集大小\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { std::unordered_map\u0026lt;char, int\u0026gt; hash; // 存储目标字符频率 for (char c : p) ++hash[c]; std::vector\u0026lt;int\u0026gt; res; int total = hash.size(), count = 0; for (int i = 0, j = 0; i \u0026lt; s.size(); ++ i) { // 右扩：加入字符 s[i] -- hash[s[i]]; if (hash[s[i]] == 0) ++ count; // 左缩：移除字符 s[j] if (i - j + 1 \u0026gt; p.size()) { if (hash[s[j]] == 0) -- count; ++ hash[s[j]]; ++ j; } // 检查是否找到异位词 if (count == total) res.push_back(j); } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/findanagrams/","title":"findAnagrams"},{"content":"3. 无重复字符的最长子串 分析 维护一个滑动窗口： 滑动窗口用两个指针表示，j 为窗口左端，i 为窗口右端 窗口内的子串为 [j, i]，保证该窗口内没有重复字符 使用哈希表记录字符出现的次数： 哈希表 hash 的 key 为字符，value 为该字符在窗口中的出现次数 移动窗口右端： 遍历字符串，右端指针 i 每次右移一格，将字符加入窗口并更新哈希表 处理重复字符： 如果窗口中出现重复字符（即当前字符的出现次数大于 1），移动左端指针 j，并在哈希表中移除字符，直到窗口内没有重复字符。 更新结果： 每次移动窗口时，计算当前窗口的长度 (i - j + 1)，并更新结果 res 时间复杂度 每个字符至多被访问两次（右指针扩展时访问一次，左指针收缩时访问一次），时间复杂度为 O(n)\n空间复杂度 使用哈希表存储字符出现次数，空间复杂度为 O(k)，其中 k 为字符集大小\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int lengthOfLongestSubstring(string s) { std::unordered_map\u0026lt;char, int\u0026gt; hash; // 记录字符出现次数 int res = 0; // 最长子串长度 for (int i = 0, j = 0; i \u0026lt; s.size(); ++ i) { ++hash[s[i]]; // 将字符加入窗口 // 如果出现重复字符，移动左指针 j while (hash[s[i]] \u0026gt; 1) { -- hash[s[j]]; ++ j; } // 更新最长子串长度 res = std::max(res, i - j + 1); } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/lengthoflongestsubstring/","title":"lengthOfLongestSubstring"},{"content":"239. 滑动窗口最大值 分析 维护一个单调递减队列：\n使用一个双端队列 q 存储数组的索引 队列中的元素对应的值保持单调递减顺序，队首始终是当前窗口的最大值索引 窗口滑动的处理：\n窗口失效处理：检查队首索引是否超出当前窗口范围 (i - k + 1)，若超出则弹出队首 保持单调性：将新元素加入队列时，弹出队列中所有小于当前元素值的索引，以确保队列的单调递减性 记录最大值：当窗口的大小达到 k 时 (i \u0026gt;= k - 1)，窗口的最大值即为队首索引对应的值 时间复杂度 遍历数组：所有元素仅被插入和弹出队列一次，时间复杂度为 O(n) 队列操作：每次插入和弹出操作的平均时间复杂度为 O(1) 总时间复杂度：O(n)\n空间复杂度 使用了一个双端队列存储索引，空间复杂度为 O(k)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::deque\u0026lt;int\u0026gt; q; // 双端队列存储索引 std::vector\u0026lt;int\u0026gt; res; // 存储结果 for (int i = 0; i \u0026lt; nums.size(); ++i) { // 移除队首超出窗口范围的元素 if (q.size() \u0026amp;\u0026amp; q.front() \u0026lt; i - k + 1) q.pop_front(); // 保持队列单调递减 while (q.size() \u0026amp;\u0026amp; nums[q.back()] \u0026lt;= nums[i]) q.pop_back(); // 添加当前元素索引到队列 q.push_back(i); // 当窗口形成时，记录窗口最大值 if (i \u0026gt;= k - 1) res.push_back(nums[q.front()]); } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxslidingwindow/","title":"maxSlidingWindow"},{"content":"76. 最小覆盖子串 分析 记录目标字符频率： 使用哈希表 hashT 记录字符串 t 中每个字符的频率。 维护当前窗口的字符频率： 使用另一个哈希表 hashS 记录当前窗口内字符的频率。 滑动窗口： 扩展窗口：从左到右遍历字符串 s，将当前字符加入窗口，并更新 hashS 满足条件：当窗口中的字符满足 t 中的所有字符（包括频率要求），记录当前窗口长度 收缩窗口：尝试从窗口左端收缩，以找到更小的满足条件的子串 更新结果： 如果窗口当前覆盖所有所需字符且长度更短，则更新结果字符串 时间复杂度 遍历字符串 s：每个字符至多被访问两次（一次扩展窗口，一次收缩窗口），时间复杂度为 O(n) 更新哈希表：更新和查询哈希表的操作时间复杂度为 O(1) 总时间复杂度：O(n)\n空间复杂度 使用了两个哈希表存储字符频率，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: string minWindow(string s, string t) { std::unordered_map\u0026lt;char, int\u0026gt; hashS, hashT; for (char c : t) ++ hashT[c]; // 记录目标字符串 t 的字符频率 int cnt = 0; // 当前窗口内满足条件的字符个数 std::string res; // 记录结果子串 for (int i = 0, j = 0; i \u0026lt; s.size(); ++i) { ++ hashS[s[i]]; // 扩展窗口 if (hashS[s[i]] \u0026lt;= hashT[s[i]]) ++ cnt; // 更新满足条件的字符数 // 收缩窗口：移除多余的字符 while (hashS[s[j]] \u0026gt; hashT[s[j]]) { -- hashS[s[j]]; ++ j; } // 检查当前窗口是否满足条件 if (cnt == t.size()) if (res.empty() || res.size() \u0026gt; i - j + 1) res = s.substr(j, i - j + 1); // 更新结果 } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxwindow/","title":"maxWindow"},{"content":"560. 和为k的子数组 分析 定义前缀和：\n用 sum 表示从数组起点到当前位置的元素总和 任意连续子数组的和可以通过前缀和的差来计算：sum[i] - sum[j] = k =\u0026gt; sum[i] - k = sum[j] 使用哈希表存储前缀和出现的次数：\n哈希表 hash 的键表示前缀和的值，值表示该前缀和出现的次数 初始状态下，将前缀和 0 的计数置为 1（代表从起点到当前位置的子数组和可能为 k ） 遍历数组，动态更新结果：\n遍历数组中的每个元素，将当前值累加到 sum 检查 hash 中是否存在键 sum - k： 若存在，说明从某个之前的位置到当前的位置的子数组和为 k ，将其对应的次数累加到结果 res 中 更新 hash，增加当前前缀和 sum 的计数 返回结果：\n遍历结束后，结果 res 即为和为 k 的子数组个数 时间复杂度 遍历数组：O(n)，其中 n 是数组的长度 哈希表操作：平均时间复杂度为 O(1) 总时间复杂度：O(n)\n空间复杂度 使用了哈希表存储前缀和及其次数，空间复杂度为 O(n)，其中 n 是数组的长度\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public: int subarraySum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { std::unordered_map\u0026lt;int, int\u0026gt; hash; // 存储前缀和及其出现次数 int res = 0, sum = 0; hash[0] = 1; // 初始化前缀和 0 的计数为 1 for (int num : nums) { sum += num; // 更新前缀和 res += hash[sum - k]; // 检查是否存在前缀和满足条件 ++ hash[sum]; // 更新当前前缀和的计数 } return res; } }; ","date":"2024-11-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/subarraysum/","title":"subarraySum"},{"content":"49. 字母异位词分组 分析 核心思想： 字母异位词在字母排序后，其排序结果是相同的。例如： \u0026quot;eat\u0026quot; 和 \u0026quot;tea\u0026quot; 排序后都为 \u0026quot;aet\u0026quot; 因此，可以将排序后的字符串作为键，将所有字母异位词分组存储在一个哈希表中 步骤： 遍历字符串数组，对每个字符串进行排序，得到其标准形式 将排序后的字符串作为键，将原始字符串加入到对应的哈希表键值中 遍历哈希表，提取所有的值（即字母异位词组） 时间复杂度 排序： 每个字符串排序的时间复杂度为 O(klogk) ，其中 k 是字符串的平均长度 总的排序复杂度为 O(n * klogk) ，其中 n 是字符串数组的大小 哈希表操作： 插入和查找操作的平均复杂度为 O(1) 总时间复杂度为 O(n * klogk)\n空间复杂度 哈希表存储：需要存储排序后的字符串和对应的原始字符串列表，空间复杂度为 O(n * k) 额外字符串副本：排序时需要创建字符串副本，额外空间复杂度为 O(k) 总空间复杂度为 O(n * k)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; groupAnagrams(std::vector\u0026lt;std::string\u0026gt;\u0026amp; strs) { std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; res; // 存储最终结果 std::unordered_map\u0026lt;std::string, std::vector\u0026lt;std::string\u0026gt;\u0026gt; hash; // 哈希表用于分组 // 遍历字符串数组 for (string str : strs) { std::string word = str; // 创建副本以便排序 std::sort(word.begin(), word.end()); // 排序字符串 hash[word].push_back(str); // 将原始字符串加入对应组 } // 遍历哈希表，将值部分（分组结果）加入结果 for (auto e : hash) res.push_back(e.second); return res; // 返回分组后的结果 } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/groupanagrams/","title":"groupAnagrams"},{"content":"128. 最长连续序列 分析 使用哈希集合 (unordered_set)：\n首先将数组中的所有元素存入一个哈希集合 s 中，便于快速判断某个数字是否存在 遍历数组，寻找序列起点：\n对于每个数字 start，如果 start - 1 不存在于集合中，说明它是某个连续序列的起点 从这个起点开始，逐步检查 start + 1, start + 2, … 是否存在于集合中，计算连续序列的长度 优化：删除已访问元素：\n在遍历过程中，一旦某个数字被处理，可以从集合中删除，避免后续重复处理 更新结果：\n记录所有连续序列的最大长度 时间复杂度 构建哈希集合：O(n) ，其中 n 是数组长度\n遍历数组：\n每个元素最多被访问两次（一次作为序列起点，一次作为序列中元素） 总复杂度为 O(n) 总时间复杂度为 O(n)\n空间复杂度 使用了一个哈希集合存储数组中的所有元素，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int longestConsecutive(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::unordered_set\u0026lt;int\u0026gt; s; // 哈希集合存储所有数字 for (int num : nums) s.insert(num); int res = 0; // 记录最长连续序列的长度 for (int start : nums) { // 如果 start 是序列的起点（前一个数字不存在） if (s.count(start) \u0026amp;\u0026amp; !s.count(start - 1)) { int end = start; // 初始化序列的起点 s.erase(end); // 移除起点，避免重复处理 // 找到当前序列的结尾 while (s.count(end + 1)) { end += 1; s.erase(end); // 同样移除，优化后续查询 } // 更新最长长度 res = std::max(res, end - start + 1); } } return res; } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longestconsecutivesequence/","title":"longestConsecutiveSequence"},{"content":"11. 盛最多水的容器 分析 容器的水量由两条垂线的较小高度和它们之间的水平距离决定，公式为：min(height[i], height[j]) * (j - i)\n初始时，将左右指针分别置于数组的两端 计算当前两条垂线能容纳的水量，并更新最大水量 移动高度较小的一侧的指针： 因为容器的水量由两条垂线的较小高度决定，移动较小高度的一侧可能增加更高的高度，从而得到更大的水量 当左右指针相遇时，遍历结束，最大水量即为结果 时间复杂度 指针遍历：每次移动一个指针，最多遍历数组一次，时间复杂度为 O(n)\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = 0; // 存储最大水量 int i = 0, j = height.size() - 1; // 初始化左右指针 while (i \u0026lt; j) { // 计算当前容器的水量 res = std::max(res, std::min(height[i], height[j]) * (j - i)); // 移动高度较小的一侧 if (height[i] \u0026lt; height[j]) ++ i; else -- j; } return res; // 返回最大水量 } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxarea/","title":"maxArea"},{"content":"283. 移动零 分析 i 用于记录非零元素的位置 遍历数组时，将非零元素按顺序填入数组前部，并记录当前插入的位置 遍历完成后，数组前部已填满非零元素，后续位置全部填充 0 时间复杂度 遍历数组一次，时间复杂度为 O(n) 填充零的操作也是 O(n) ，但两者不重叠，总体为O(n) 空间复杂度 使用了两个指针变量，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = 0; // 指针 i，用于记录下一个非零元素的位置 // 1. 遍历数组，将所有非零元素依次放到前部 for (int num : nums) { if (num != 0) { nums[i++] = num; // 将非零元素放入 i 位置，并移动 i } } // 2. 将剩余位置填充为 0 while (i \u0026lt; nums.size()) { nums[i++] = 0; } } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/movezeroes/","title":"moveZeroes"},{"content":"42. 接雨水 分析 条件： 雨水的高度由当前柱子左右两边的最高柱子决定 能接的雨水量为两侧最高柱子中较小值减去当前柱子的高度 预处理左右最高高度： 左侧最高高度数组 (left_max)： 遍历数组，从左到右记录当前位置左侧的最高柱子 右侧最高高度数组 (right_max)： 遍历数组，从右到左记录当前位置右侧的最高柱子 计算雨水量： 遍历数组，每个位置接的雨水为 min(left_max[i], right_max[i]) - height[i] 累加所有位置的雨水量，得到最终结果 时间复杂度 构建 left_max 和 right_max：O(n) 计算雨水量：O(n) 总复杂度：O(n)\n空间复杂度 需要额外的两个数组存储 left_max 和 right_max，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int n = height.size(); if (n == 0) return 0; // 边界条件，空数组返回 0 // 1. 构建左侧最高高度数组 std::vector\u0026lt;int\u0026gt; left_max(n); left_max[0] = height[0]; for (int i = 1; i \u0026lt; n; ++i) left_max[i] = std::max(left_max[i - 1], height[i]); // 2. 构建右侧最高高度数组 std::vector\u0026lt;int\u0026gt; right_max(n); right_max[n - 1] = height[n - 1]; for (int i = n - 2; i \u0026gt;= 0; --i) right_max[i] = std::max(right_max[i + 1], height[i]); // 3. 计算总雨水量 int res = 0; for (int i = 0; i \u0026lt; n; ++i) res += std::min(left_max[i], right_max[i]) - height[i]; return res; } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/trap/","title":"trap"},{"content":"31. LRUCache 分析 LRU（Least Recently Used）是一种缓存替换策略，淘汰最久未被使用的数据，以保证缓存内存的有效利用率\n核心数据结构：\n双向链表：维护缓存访问顺序，最新使用的数据放在链表头，最久未使用的数据放在链表尾。双向链表的插入和删除操作可以在 O(1) 时间内完成，适用于缓存频繁更新的场景 哈希表：通过关键字快速定位链表中的节点 get(key)：\n若 key 存在，将对应节点移动到链表头，并返回其值 若 key 不存在，返回 -1 put(key, value)：\n若 key 已存在，更新其值并移动到链表头 若 key 不存在： 如果缓存已满，删除链表尾的节点（最久未使用） 将新节点插入到链表头 时间复杂度 get(key)：O(1)\n哈希表查找节点是 O(1) ，双向链表操作也是 O(1) put(key, value)：O(1)\n哈希表插入和删除是 O(1) ，双向链表操作也是 O(1) 空间复杂度 哈希表和双向链表的空间复杂度均为 O(n) ，其中 n 是缓存容量 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class LRUCache { public: // 定义双向链表节点 struct Node { Node(int key, int value) : m_key(key), m_value(value) , prev(nullptr), next(nullptr) {} int m_key, m_value; Node *prev, *next; }; int n; // 缓存容量 Node *head, *tail; // 双链表的虚拟头节点 std::unordered_map\u0026lt;int, Node*\u0026gt; hash; // 哈希表，快速查找节点 // 初始化 LRU 缓存 LRUCache(int capacity) { n = capacity; head = new Node(-1, -1); // 创建虚拟头节点 tail = new Node(-1, -1); // 创建虚拟尾节点 head-\u0026gt;next = tail; // 初始化双向链表 tail-\u0026gt;prev = head; } // 从链表中删除指定节点 void remove(Node* cur) { cur-\u0026gt;next-\u0026gt;prev = cur-\u0026gt;prev; cur-\u0026gt;prev-\u0026gt;next = cur-\u0026gt;next; } // 在链表头部插入指定节点 void insert(Node* cur) { cur-\u0026gt;next = head-\u0026gt;next; cur-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = cur; head-\u0026gt;next = cur; } // 获取节点的值 int get(int key) { if (!hash.count(key)) // 节点不存在 return -1; Node* cur = hash[key]; // 定位节点 remove(cur); // 更新节点在链表中的位置 insert(cur); return cur-\u0026gt;m_value; } // 插入或更新节点 void put(int key, int value) { if (hash.count(key)) // 节点已存在 { Node* cur = hash[key]; cur-\u0026gt;m_value = value; // 更新节点值 remove(cur); // 更新节点位置 insert(cur); } else // 节点不存在 { if (hash.size() == n) // 缓存已满 { Node* cur = tail-\u0026gt;prev; // 取出尾节点 remove(cur); // 从链表中移除 hash.erase(cur-\u0026gt;m_key); // 从哈希表中删除 } Node* cur = new Node(key, value); // 创建新节点 insert(cur); // 插入链表头 hash[key] = cur; // 添加到哈希表 } } }; ","date":"2024-11-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/lrucache/","title":"LRUCache"},{"content":"56. mergeIntervals 分析 排序： 首先将所有区间按照起始值从小到大排序。排序后，若两个区间有重叠，它们一定是相邻的 遍历与合并： 用变量 l 和 r 分别表示当前合并区间的起始和结束 遍历排序后的区间： 如果当前遍历区间的起始值大于当前合并区间的结束值 r，说明当前区间与前面的合并区间没有重叠，应将前面的合并区间加入结果，并更新 l 和 r 如果有重叠，则将 r 更新为当前区间结束值的较大值 遍历结束后，将最后一个合并区间加入结果 时间复杂度 排序：O(nlogn) ，n 是区间的数量 遍历：O(n)，每个区间只会被处理一次 总时间复杂度为 O(nlogn)\n空间复杂度 排序所需的额外空间复杂度为 O(logn) （排序算法的递归栈空间） 结果存储的空间复杂度为 O(n) 总空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 用于存储最终结果 if (intervals.empty()) return res; // 如果输入为空，直接返回空数组 // 1. 按区间的起始值排序 sort(intervals.begin(), intervals.end()); // 2. 初始化合并区间的左右边界 int l = intervals[0][0], r = intervals[0][1]; // 3. 遍历剩余区间 for (int i = 1; i \u0026lt; intervals.size(); ++ i) { // 当前区间的起始值 \u0026gt; 当前合并区间的结束值，说明没有重叠 if (r \u0026lt; intervals[i][0]) { res.push_back({l, r}); // 将当前合并区间加入结果 l = intervals[i][0]; // 更新新的合并区间的起始值 r = intervals[i][1]; // 更新新的合并区间的结束值 } else { // 如果有重叠，则更新当前合并区间的结束值 r = max(r, intervals[i][1]); } } // 将最后一个合并区间加入结果 res.push_back({l, r}); return res; } }; ","date":"2024-11-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/mergeintervals/","title":"mergeIntervals"},{"content":"152. maxProduct 分析 使用f[i - 1]记录所有以nums[i - 1]元素结尾的连续子数组中的最大乘积\n使用g[i - 1]记录所有以nums[i - 1]元素结尾的连续子数组中的最小乘积\n求f[i]\n当nums[i]为正数时，f[i] = std::max(nums[i], f[i - 1] * nums[i])，因为正数与最大值相乘，值最大，所以与f[i - 1]相乘 当nums[i]为负数时，f[i] = std::max(nums[i], g[i - 1] * nums[i])，因为负数与最小值相乘，值最大，所以与g[i - 1]相乘 求g[i]\n当nums[i]为正数时，g[i] = std::min(nums[i], g[i - 1] * nums[i])，因为正数与最小值相乘，值最小，所以与g[i - 1]相乘 当nums[i]为负数时，g[i] = std::min(nums[i], f[i - 1] * nums[i])，因为负数与最大值相乘，值最小，所以与f[i - 1]相乘 当nums[i]为0时，f[i]和g[i]都变为0，即连续子数组断开，从下一个元素重新开始找最大乘积\n优化：因为每次更新f[i]和g[i]只需要前一个数，所以不需要开两个数组记录所有值\n时间复杂度：O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; int f_last = nums[0], g_last = nums[0]; for (int i = 1; i \u0026lt; nums.size(); ++ i) { int f_cur = f_last * nums[i], g_cur = g_last * nums[i]; f_last = std::max(nums[i], std::max(f_cur, g_cur)); g_last = std::min(nums[i], std::min(f_cur, g_cur)); res = std::max(res, f_last); } return res; } }; ","date":"2024-11-23T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxproduct/","title":"maxProduct"},{"content":"190. reverseBits 分析 核心步骤：取二进制数的第i位n \u0026gt;\u0026gt; i \u0026amp; 1\nres每次左移一位，然后将n的最低位加到res上\nC++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t res = 0; for (int i = 0; i \u0026lt; 32; ++ i) res = (res \u0026lt;\u0026lt; 1) + (n \u0026gt;\u0026gt; i \u0026amp; 1); return res; } }; ","date":"2024-11-23T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reversebits/","title":"reverseBits"},{"content":"15. 三数之和 分析 排序数组： 首先将数组从小到大排序，方便后续操作 固定一个数，双指针搜索： 遍历排序后的数组，用 i 指向当前固定的数 在 i 的右侧，使用双指针 j 和 k： j 指向 i + 1 k 指向数组末尾 检查三数之和： 若三数之和小于 0，说明需要更大的值，移动 j 向右 若三数之和大于 0，说明需要更小的值，移动 k 向左 若三数之和等于 0，记录结果，同时移动 j 和 k 跳过重复值 去重： 对于固定数 nums[i]，若 nums[i] = nums[i-1]，跳过当前遍历，避免重复三元组 对于 nums[j] 和 nums[k]，在找到一个解后，继续移动跳过相同值 时间复杂度 排序复杂度：O(nlogn) 三重循环复杂度：外层循环 O(n)，内层双指针 O(n)，总复杂度为 O(n^2) 总时间复杂度 O(n^2)\n空间复杂度 使用排序 O(logn) 的额外空间，其余操作在原地完成，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::vector\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; res; std::sort(nums.begin(), nums.end()); // 对数组进行排序 for (int i = 0; i \u0026lt; nums.size(); ++i) { // 跳过重复的固定数 if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; // 双指针寻找其他两数 for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; ++ j) { // 跳过重复的第二个数 if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; // 移动右指针，寻找满足条件的三元组 while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) -- k; // 判断当前三数之和是否为零 if (nums[i] + nums[j] + nums[k] == 0) res.push_back({nums[i], nums[j], nums[k]}); } } return res; } }; ","date":"2024-11-22T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/threesum/","title":"threeSum"},{"content":"1. 两数之和 分析 利用哈希表存储数组元素及其下标： 使用一个哈希表，键为数组元素值，值为对应的下标 哈希表可以快速查询某个元素是否已经出现过 遍历数组，寻找目标值对应的数： 在遍历数组时，对于当前元素 nums[i]，计算另一个需要的数 x = target - nums[i]； 在哈希表中检查是否存在 x： 如果 x 存在，说明找到了两个数，返回它们的下标 如果 x 不存在，将当前数 nums[i] 及其索引存入哈希表，继续遍历 时间复杂度 哈希表查询和插入：每次操作 O(1) 数组遍历：遍历一次数组，时间复杂度为 O(n) 总时间复杂度 O(n)\n空间复杂度 需要一个哈希表存储数组中的元素及其索引，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { std::unordered_map\u0026lt;int, int\u0026gt; hash; // 哈希表存储元素值及其索引 for (int i = 0; i \u0026lt; nums.size(); ++ i) { int x = target - nums[i]; // 计算需要的数 // 检查是否在哈希表中 if (hash.count(x)) return {hash[x], i}; // 找到目标值，返回下标 // 将当前数存入哈希表 hash[nums[i]] = i; } return {}; // 如果无解，返回空数组（题目保证一定有解） } }; ","date":"2024-11-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/twosum/","title":"twoSum"},{"content":"33. Search in Rotated Sorted Array 分析 找旋转点： 通过二分查找，判断 nums[mid] 和 nums[0] 的关系： 如果 nums[mid] \u0026gt;= nums[0]，说明 mid 在前半部分，继续搜索右侧 否则，说明 mid 在后半部分，继续搜索左侧 最终 r 指向旋转点前的最后一个位置 确定搜索范围： 如果 target \u0026gt;= nums[0]，说明目标值在前半部分，设置 l = 0 否则，目标值在后半部分，设置 l = r + 1，r = nums.size() - 1 二分查找目标值： 普通的二分查找，最终检查 nums[r] 是否等于目标值 时间复杂度 找旋转点和目标值各需要一次二分查找，每次的时间复杂度为 O(log n) 总体时间复杂度为 O(log n)\n空间复杂度 使用常量级别额外空间，空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.empty()) // 特殊情况：数组为空 return -1; // 第一次二分查找：找到旋转点 int l = 0, r = nums.size() - 1; while (l \u0026lt; r) { int mid = (l + r + 1) \u0026gt;\u0026gt; 1; // 偏向右侧 if (nums[0] \u0026lt;= nums[mid]) l = mid; // 旋转点在右侧 else r = mid - 1; // 旋转点在左侧 } // 确定搜索范围 if (target \u0026gt;= nums[0]) // 目标值在前半部分 l = 0; else // 目标值在后半部分 { l = r + 1; r = nums.size() - 1; } // 第二次二分查找：找到目标值 while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (target \u0026lt;= nums[mid]) r = mid; // 收缩右边界 else l = mid + 1; // 收缩左边界 } // 检查是否找到目标值 if (target == nums[r]) return r; return -1; } }; ","date":"2024-04-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/search-in-rotated-sorted-array/","title":"Search in Rotated Sorted Array"},{"content":"32. Longest Valid Parentheses 分析 遍历字符串，当遇到 '(' 时，将索引入栈 遇到 ')' 时，分两种情况： 如果栈不为空，说明当前 ')' 可以与之前的 '(' 配对： 弹出栈顶索引 如果栈仍不为空，则当前有效括号长度为 i - stk.top() 如果栈为空，则当前有效括号长度为 i - end 如果栈为空，说明当前 ')' 无法配对，将其索引更新为 end 每次更新最长有效括号长度 res 时间复杂度： 遍历字符串一次，每个索引至多入栈、出栈一次，时间复杂度为 O(n)\n空间复杂度 使用栈存储括号索引，最坏情况下栈中存储所有的左括号，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public: int longestValidParentheses(string s) { std::stack\u0026lt;int\u0026gt; stk; // 用于存储未匹配的括号索引 int end = -1; // 记录最后一个无法匹配的右括号索引 int res = 0; // 记录最长有效括号长度 for (int i = 0; i \u0026lt; s.size(); ++i) { if (s[i] == \u0026#39;(\u0026#39;) stk.push(i); // 左括号入栈 else { if (!stk.empty()) // 有未匹配的左括号 { stk.pop(); // 配对成功，弹出栈顶 if (!stk.empty()) res = std::max(res, i - stk.top()); // 栈不为空，用当前索引减去栈顶索引 else res = std::max(res, i - end); // 栈为空，用当前索引减去 `end` } else end = i; // 当前右括号无法配对，更新 `end` } } return res; // 返回最长有效括号长度 } }; ","date":"2024-04-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-valid-parentheses/","title":"Longest Valid Parentheses"},{"content":"31. Next Permutation 分析 首先，找到排列中从右往左第一个非递增的数字，记其索引为 k。 如果 k 为 0 或者更小，则说明当前排列已经是最大的排列，因此直接将整个排列反转即可得到最小的排列。 否则，从索引 k 开始往右查找，找到比索引 k-1 处元素大的最小元素，并将其与索引 k-1 处的元素交换。 最后，将索引 k 右侧的元素逆序排列，以确保得到的排列是比原排列大的下一个字典序排列。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int k = nums.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k - 1] \u0026gt;= nums[k]) k -- ; if (k \u0026lt;= 0) reverse(nums.begin(), nums.end()); else { int t = k; while (t \u0026lt; nums.size() \u0026amp;\u0026amp; nums[t] \u0026gt; nums[k - 1]) t ++ ; swap(nums[k - 1], nums[t - 1]); reverse(nums.begin() + k, nums.end()); } } }; ","date":"2024-04-01T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/next-permutation/","title":"Next Permutation"},{"content":"29. Divide Two Integers 分析 用位运算模拟除法过程\n例如，对于$\\frac{x}{y}=k$， 将k转换成2进制的形式，有$k = 2^{0} + 2^{1} + \u0026hellip; + 2^{31}$\n我们可以将每一位的值存下来，然后从高位向低位遍历，只要 x 大于当前位的值，x 就减去当前位的值\n又因为$x=yk=y2^0+y2^1+\u0026hellip;+y2^{31}$，所以每次 x 减去第i位的值时，最终要求得的商就加上 $2^{i}$\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int divide(int dividend, int divisor) { typedef long long LL; vector\u0026lt;LL\u0026gt; exp; bool is_minus = false; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) is_minus = true; LL a = abs((LL)dividend), b = abs((LL)divisor); for (LL i = b; i \u0026lt;= a; i = i + i) exp.push_back(i); LL res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i -- ) { if (a \u0026gt;= exp[i]) { a -= exp[i]; res += (LL)1 \u0026lt;\u0026lt; i; } } if (is_minus) res = -res; if (res \u0026gt; INT_MAX) res = INT_MAX; if (res \u0026lt; INT_MIN) res = INT_MIN; return res; } }; ","date":"2024-03-30T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/divide-two-integers/","title":"Divide Two Integers"},{"content":"28. Find the Index of the First Occurrence in a String 分析 在源传和目标串首部添加一个字符，使得下标匹配从1开始，方便处理。 构建目标串的 next 数组。具体来说，对于目标串的任意位置 i，我们要找到一个数 j，使得 needle[1:j] 和 needle[i-j+1:i] 是相等的，并且 j 的值尽可能大。每个 next[i] 对应一个 j 。 遍历源串，在匹配过程中，若 haystack[i] 与 needle[j+1] 不相等，则将 j 回溯到 next[j]。若相等，则同时向后移动 i 和 j。若 j 移动到 needle 的末尾，则表示在 haystack 中找到了 needle，返回 i - m 即可。 时间复杂度为 O(n+m)，其中 n 和 m 分别是 haystack 和 needle 的长度。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; int n = haystack.size(), m = needle.size(); haystack = \u0026#39; \u0026#39; + haystack, needle = \u0026#39; \u0026#39; + needle; vector\u0026lt;int\u0026gt; next(m + 1); for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; needle[i] != needle[j + 1]) j = next[j]; if (needle[i] == needle[j + 1]) j ++ ; next[i] = j; } for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; haystack[i] != needle[j + 1]) j = next[j]; if (haystack[i] == needle[j + 1]) j ++ ; if (j == m) return i - m; } return -1; } }; ","date":"2024-03-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/find-the-index-of-the-first-occurrence-in-a-string/","title":"Find the Index of the First Occurrence in a String"},{"content":"27. Remove Element C++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int k = 0; for (int i = 0; i \u0026lt; nums.size(); i ++ ) if (nums[i] != val) nums[k ++ ] = nums[i]; return k; } }; ","date":"2024-03-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-element/","title":"Remove Element"},{"content":"26. Remove Duplicates from Sorted Array 分析 用索引 k 记录非重复元素的位置。 判断当前元素 i 是否为第一个元素 或 是否与前一个元素不等。 如果满足上述条件，将当前元素复制到数组中索引为 k 的位置，然后递增 k。 最后返回索引 k，它表示移除重复元素后的数组长度。 C++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int k = 0; for (int i = 0; i \u0026lt; nums.size(); i ++ ) if (!i || nums[i] != nums[i - 1]) nums[k ++ ] = nums[i]; return k; } }; ","date":"2024-03-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-duplicates-from-sorted-array/","title":"Remove Duplicates from Sorted Array"},{"content":"25. Reverse Nodes in k-Group 分析 引入虚拟头节点\n创建一个虚拟头节点 dummy，使其 next 指向链表的头节点，以便统一处理头节点的翻转 遍历链表检查是否需要翻转\n使用指针 cur 标记当前分组的前驱节点 检查 cur 后是否至少还有 k 个节点。如果节点数不足 k，直接退出循环 翻转当前分组的 k 个节点\n记录当前分组的起点 a 和翻转后的起点 b 按照链表翻转的规则，通过调整指针完成当前分组内的节点翻转，循环 k-1 次 连接翻转后的链表\n让当前分组的前驱节点 cur-\u0026gt;next 指向翻转后的新头节点 a 让当前分组的尾节点连接到下一分组的起始节点 b 更新 cur 为当前分组的尾节点 时间复杂度 每个节点最多被访问两次（检查和翻转），时间复杂度 O(n)\n空间复杂度 空间复杂度 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { // 创建虚拟头节点 ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; ListNode* cur = dummy; while (true) { // 检查是否有足够的节点进行翻转 ListNode* check = cur; for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; check; ++i) check = check-\u0026gt;next; if (!check) break; // 翻转当前分组的 k 个节点 ListNode *a = cur-\u0026gt;next, *b = cur-\u0026gt;next-\u0026gt;next; for (int i = 0; i \u0026lt; k - 1; ++i) { ListNode* c = b-\u0026gt;next; // 暂存下一节点 b-\u0026gt;next = a; // 翻转当前节点 a = b; // 同时后移 b = c; } // 连接翻转后的链表 ListNode* c = cur-\u0026gt;next; cur-\u0026gt;next = a; // 当前分组的前驱节点指向翻转后的新头节点 c-\u0026gt;next = b; // 当前分组的尾节点连接到下一分组的起始节点 cur = c; // 更新 cur 为当前分组的尾节点 } // 返回结果链表 return dummy-\u0026gt;next; } }; ","date":"2024-03-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reverse-nodes-in-k-group/","title":"Reverse Nodes in k-Group"},{"content":"24. Swap Nodes in Pairs 分析 创建虚拟头节点\n为了方便处理头节点的交换，创建一个虚拟头节点 dummy，使其 next 指向链表的头节点 遍历链表并交换节点\n使用指针 cur 指向当前正在处理的一对节点的前驱节点。 检查当前节点 cur-\u0026gt;next 和 cur-\u0026gt;next-\u0026gt;next 是否存在，只有在有足够节点时才进行交换 定义两个指针 p 和 q 分别指向待交换的两个节点： 交换后，cur-\u0026gt;next 指向第二个节点 q 第一个节点 p-\u0026gt;next 指向第三个节点 第二个节点 q-\u0026gt;next 指向第一个节点 将指针 cur 移动到已交换节点对的末尾，继续处理下一对 时间复杂度 时间复杂度 O(n)，遍历链表一次，其中 n 是链表的长度\n空间复杂度 空间复杂度 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: ListNode* swapPairs(ListNode* head) { // 创建虚拟头节点 ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; // 遍历链表并交换节点 for (ListNode* cur = dummy; cur-\u0026gt;next \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;next; ) { ListNode *p = cur-\u0026gt;next, *q = p-\u0026gt;next; // 定义待交换的两个节点 cur-\u0026gt;next = q; // 前驱节点指向第二个节点 p-\u0026gt;next = q-\u0026gt;next; // 第一个节点指向第三个节点 q-\u0026gt;next = p; // 第二个节点指向第一个节点 cur = p; // 移动到下一组的前驱节点 } // 返回结果链表 return dummy-\u0026gt;next; } }; ","date":"2024-03-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/swap-nodes-in-pairs/","title":"Swap Nodes in Pairs"},{"content":"23. 合并K个升序链表 分析 使用优先队列\n创建一个优先队列 heap，用于存储链表节点 队列中的元素按节点值从小到大排序（小根堆） 使用一个自定义比较器 cmp 来实现小根堆的逻辑 初始化优先队列\n将所有链表的头节点（如果非空）加入优先队列 归并链表\n每次从优先队列中取出值最小的节点 temp，将其加入新链表 如果 temp 节点还有下一个节点，则将其 next 节点加入优先队列 重复以上步骤，直到队列为空 时间复杂度 优先队列的插入和删除操作的时间复杂度为 O(logk)，其中 k 是链表的数量 每个节点都会被插入和删除一次，因此总时间复杂度为 O(nlogk)，其中 n 是链表中所有节点的总数 空间复杂度 优先队列最多同时存储 k 个节点，因此空间复杂度为 O(k)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { // 自定义比较器，用于优先队列排序 struct cmp { bool operator()(ListNode* a, ListNode* b) { return a-\u0026gt;val \u0026gt; b-\u0026gt;val; // 小根堆 } }; // 定义优先队列（小根堆） std::priority_queue\u0026lt;ListNode*, std::vector\u0026lt;ListNode*\u0026gt;, cmp\u0026gt; heap; // 初始化优先队列，将每个链表的头节点加入堆中 for (ListNode* li : lists) if (li) heap.push(li); // 定义虚拟头节点，便于操作新链表 ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; // 从优先队列中逐步取出最小值节点，并更新链表 while (!heap.empty()) { ListNode* temp = heap.top(); // 获取当前最小值节点 heap.pop(); // 将其从堆中移除 cur = cur-\u0026gt;next = temp; // 将其加入新链表 if (temp-\u0026gt;next) // 如果有后续节点，将后续节点加入堆中 { temp = temp-\u0026gt;next; heap.push(temp); } } // 返回合并后的链表 return dummy-\u0026gt;next; } }; ","date":"2024-03-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-k-sorted-lists/","title":"Merge k Sorted Lists"},{"content":"22. Generate Parentheses 分析 合法的括号组合需要满足：\n左括号 ( 的数量不能超过 n 右括号 ) 的数量不能超过左括号的数量 递归函数在每一步根据当前左括号和右括号的数量，选择是否添加 ( 或 )\n如果左括号数量小于 n，可以添加 ( 如果右括号数量小于左括号，可以添加 ) 当左右括号数量均达到 n 时，将当前路径 path 加入结果集 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public: std::vector\u0026lt;std::string\u0026gt; res; // 存储所有合法的括号组合 std::string path; // 当前生成的括号组合 vector\u0026lt;string\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0); // 从 0 左括号和 0 右括号开始递归 return res; } void dfs(int n, int l_p, int r_p) { // 如果左右括号都用完，生成一个合法组合 if (l_p == n \u0026amp;\u0026amp; r_p == n) { res.push_back(path); return; } // 尝试添加左括号 if (l_p \u0026lt; n) { path.push_back(\u0026#39;(\u0026#39;); // 添加左括号 dfs(n, l_p + 1, r_p); // 递归进入下一层 path.pop_back(); // 回溯，移除左括号 } // 尝试添加右括号 if (r_p \u0026lt; n \u0026amp;\u0026amp; r_p \u0026lt; l_p) { path.push_back(\u0026#39;)\u0026#39;); // 添加右括号 dfs(n, l_p, r_p + 1); // 递归进入下一层 path.pop_back(); // 回溯，移除右括号 } } }; ","date":"2024-03-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/generate-parentheses/","title":"Generate Parentheses"},{"content":"21. Merge Two Sorted Lists 分析 创建虚拟头节点\n创建一个虚拟头节点 dummy，用于方便拼接新链表，同时维护一个指针 cur 指向结果链表的当前末尾 比较两个链表节点值\n遍历 list1 和 list2，每次比较当前节点值，将较小值的节点接到 cur 的后面，并将对应链表的指针后移 拼接剩余节点\n如果某个链表还有剩余节点（未遍历完），直接将其接到结果链表末尾 返回结果链表\n返回虚拟头节点的下一个节点 dummy-\u0026gt;next，即为合并后的升序链表 时间复杂度 遍历两个链表，最多比较 n + m 次，其中 n 和 m 分别为两个链表的长度，时间复杂度 O(m + n)\n空间复杂度 空间复杂度 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { // 创建虚拟头节点，简化操作 ListNode *dummy = new ListNode(); ListNode* cur = dummy; // 归并两个链表 while (list1 \u0026amp;\u0026amp; list2) { if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val) // list1节点值较小 { cur = cur-\u0026gt;next = list1; // 接入结果链表 list1 = list1-\u0026gt;next; // list1指针后移 } else // list2节点值较小 { cur = cur-\u0026gt;next = list2; // 接入结果链表 list2 = list2-\u0026gt;next; // list2指针后移 } } // 拼接剩余的链表 if (list1) cur-\u0026gt;next = list1; if (list2) cur-\u0026gt;next = list2; // 返回结果链表 return dummy-\u0026gt;next; } }; ","date":"2024-03-22T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-two-sorted-lists/","title":"Merge Two Sorted Lists"},{"content":"19. Remove Nth Node From End of List 分析 创建虚拟头节点\n为了方便处理边界情况（如删除头节点），创建一个虚拟头节点 dummy，其 next 指向链表头部 计算链表长度\n遍历链表，用变量 len 记录链表的总长度 定位目标节点的前驱节点\n倒数第 n 个节点的前驱节点是正数第 len - n 个节点 从虚拟头节点开始，移动 len - n 步到目标位置 删除目标节点\n通过修改前驱节点的 next 指针，跳过目标节点 时间复杂度 需要遍历链表两次，计算链表长度和定位目标节点位置，时间复杂度 O(L)， L 是链表长度\n空间复杂度 空间复杂度 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { // 创建虚拟头节点 ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; // 计算链表长度 int len = 0; for (ListNode* p = dummy; p; p = p-\u0026gt;next) ++len; // 定位到要删除节点的前驱节点 ListNode* p = dummy; for (int i = 0; i \u0026lt; len - n - 1; ++i) p = p-\u0026gt;next; // 删除目标节点 p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; // 返回结果链表 return dummy-\u0026gt;next; } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-nth-node-from-end-of-list/","title":"Remove Nth Node From End of List"},{"content":"20. Valid Parentheses 分析 利用 栈 来检查括号匹配：\n核心规则： 左括号 (, [, { 是合法起始符号，直接入栈 遇到右括号 ), ], } 时，检查栈顶的左括号是否能匹配： 如果匹配，则栈顶元素出栈 如果不匹配，字符串无效，直接返回 false 遍历结束后，如果栈为空，则字符串有效；否则无效。 匹配判断： 两个字符匹配的条件是：abs(栈顶字符 - 当前字符) \u0026lt;= 2 ASCII 值中： ( 和 ) 相差 1 [ 和 ] 相差 2 { 和 } 相差 2 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: bool isValid(string s) { // 特殊情况处理：空字符串 if (s.empty()) return true; // 使用栈存储左括号 std::stack\u0026lt;char\u0026gt; stk; // 遍历字符串 for (char c : s) { // 如果是左括号，入栈 if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) stk.push(c); else { // 如果栈不为空并且栈顶括号能匹配当前右括号 if (stk.size() \u0026amp;\u0026amp; abs(stk.top() - c) \u0026lt;= 2) stk.pop(); // 匹配成功，栈顶出栈 else return false; // 不匹配，直接返回 false } } // 遍历结束后检查栈是否为空 return stk.empty(); } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/valid-parentheses/","title":"Valid Parentheses"},{"content":"18. 4Sum 分析 与三数之和一样，只是这里要枚举两个位置 i 和 j。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: typedef long long LL; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); j ++ ) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; for (int k = j + 1, l = nums.size() - 1; k \u0026lt; l; k ++ ) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) continue; while (l - 1 \u0026gt; k \u0026amp;\u0026amp; (LL)nums[i] + nums[j] + nums[k] + nums[l - 1] \u0026gt;= target) l -- ; if ((LL)nums[i] + nums[j] + nums[k] + nums[l] == (LL)target) { res.push_back({nums[i], nums[j], nums[k], nums[l]}); } } } } return res; } }; ","date":"2024-03-20T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/4sum/","title":"4Sum"},{"content":"17. Letter Combinations of a Phone Number 分析 使用深度优先搜索（DFS）+ 回溯的方法。\n遍历数字字符串，按每个数字对应的字母集依次尝试： 对当前数字的每个字母，将其加入组合路径中 递归进入下一个数字，直到遍历完所有数字，将当前组合加入结果集 回溯到上一步，尝试其他可能性 时间复杂度 数字字符串的长度为 n，每个数字对应最多 4 个字母。构造所有组合的时间复杂度为 O(4^n)\n空间复杂度 递归深度为 n，路径存储需要 O(n)。 结果集存储需要 O(4^n * n) C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public: std::vector\u0026lt;std::string\u0026gt; res; // 存储结果集 std::string path; // 当前路径 std::vector\u0026lt;std::string\u0026gt; strs = { // 数字对应的字母集 \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34; }; vector\u0026lt;string\u0026gt; letterCombinations(string digits) { if (digits.empty()) // 特殊情况处理：空字符串 return res; dfs(digits, 0); // 从第一个数字开始递归 return res; } void dfs(std::string\u0026amp; digits, int u) { if (u == digits.size()) { res.push_back(path); // 将当前路径加入结果集 return; } for (char c : strs[digits[u] - \u0026#39;0\u0026#39;]) // 遍历当前数字对应的字母集 { path.push_back(c); // 将当前字母加入路径 dfs(digits, u + 1); // 递归到下一个数字 path.pop_back(); // 回溯，移除最后一个字母 } } }; ","date":"2024-03-19T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/letter-combinations-of-a-phone-number/","title":"Letter Combinations of a Phone Number"},{"content":"16. 3Sum Closest 分析 暴力做法就是三重循环，每种答案枚举一遍，求一个最接近的值。\n用双指针优化。先枚举位置i，对每一个位置j，找到一个最小的位置k使得 nums[i] + nums[j] + nums[k] \u0026gt;= target，这样可以得到大于等于target的最小值。并且，当k满足前述条件时，必然有 nums[i] + nums[j] + nums[k - 1] \u0026lt; target，也就可以得到小于target的最大值。每次更新下这两个值即可。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(), nums.end()); pair\u0026lt;int, int\u0026gt; res(INT_MAX, INT_MAX); for (int i = 0; i \u0026lt; nums.size(); i ++ ) for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++ ) { while (k - 1 \u0026gt; j \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) k -- ; int s = nums[i] + nums[j] + nums[k]; res = min(res, make_pair(abs(s - target), s)); if (k - 1 \u0026gt; j) { s = nums[i] + nums[j] + nums[k - 1]; res = min(res, make_pair(target - s, s)); } } return res.second; } }; ","date":"2024-03-18T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/3sum-closest/","title":"3Sum Closest"},{"content":"14. Longest Common Prefix 分析 首先看所有字符串第一个字符是否一样，一样则公共字符串长度至少为1，否则公共字符串为空。 再看第二个字符是否一样，这样一直遍历下去\u0026hellip; 最坏情况就是把所有字符串的每个字符枚举一遍，时间复杂度小于等于所有字符串之和。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (i \u0026gt;= str.size() || str[i] != c) return res; res += c; } return res; } }; ","date":"2024-03-16T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-common-prefix/","title":"Longest Common Prefix"},{"content":"13. Roman to Integer 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 罗马数字采用加法规则，但某些情况下需要减法规则，例如：\n加法规则：VI = 5 + 1 = 6，LXX = 50 + 10 + 10 = 70 减法规则：IV = 5 - 1 = 4，IX = 10 - 1 = 9 映射数值：\n使用哈希表将罗马字符与对应数值建立映射关系，便于快速查找 遍历字符串：\n加法逻辑： 如果当前字符的数值大于等于后一个字符的数值，直接将当前字符的数值加到结果中 减法逻辑： 如果当前字符的数值小于后一个字符的数值，则根据减法规则，将当前字符的数值从结果中减去。 边界处理：\n遍历时检查 i + 1 是否越界，确保安全访问下一个字符 返回结果：\n遍历完成后，累加结果即为罗马数字对应的整数 时间复杂度： 遍历字符串一次，查找哈希表的时间复杂度为 O(1)，因此整体为 O(n)，其中 n 是字符串的长度\n空间复杂度 空间复杂度为 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int romanToInt(string s) { // 哈希表：罗马字符到数值的映射 std::unordered_map\u0026lt;char, int\u0026gt; hash; hash[\u0026#39;I\u0026#39;] = 1; hash[\u0026#39;V\u0026#39;] = 5; hash[\u0026#39;X\u0026#39;] = 10; hash[\u0026#39;L\u0026#39;] = 50; hash[\u0026#39;C\u0026#39;] = 100; hash[\u0026#39;D\u0026#39;] = 500; hash[\u0026#39;M\u0026#39;] = 1000; int res = 0; // 存储最终结果 for (int i = 0; i \u0026lt; s.size(); ++i) { // 判断是否满足减法规则 if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) res -= hash[s[i]]; // 减去当前字符的数值 else res += hash[s[i]]; // 加上当前字符的数值 } return res; // 返回结果 } }; ","date":"2024-03-15T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/roman-to-integer/","title":"Roman to Integer"},{"content":"12. Integer to Roman 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 1234 转换成罗马数字是 MCCXXXIV，也就是从千位到个位依次拼接，用代码将过程模拟出来即可\n分解数值： 定义一个从大到小排列的数值数组 values，以及对应的罗马数字字符串数组 romans 数值包括基本符号（如 1000, 500）及特殊减法组合（如 900, 400） 逐步转换： 遍历数值数组 values，对于每个值，检查当前数字 num 是否大于等于该值 若是，则从 num 中减去该值，同时将对应的罗马数字添加到结果字符串中 重复上述步骤，直到 num 为 0 输出结果： 返回拼接的罗马数字字符串 时间复杂度 常数时间复杂度 O(1)\n空间复杂度 常数空间复杂度 O(1)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public: string intToRoman(int num) { // 定义数值和对应的罗马数字 std::vector\u0026lt;int\u0026gt; values = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; std::vector\u0026lt;std::string\u0026gt; romans = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; std::string res; // 遍历数值数组 for (int i = 0; i \u0026lt; values.size(); ++i) { // 减去当前值，拼接对应罗马数字 while (num \u0026gt;= values[i]) { num -= values[i]; res += romans[i]; } } return res; } }; ","date":"2024-03-14T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/integer-to-roman/","title":"Integer to Roman"},{"content":"11. Container With Most Water 分析 用两个指针i和j分别指向开头和结尾，如果指针i指向的水柱高度较低，则指针i向后移，反之指针j向前移。每移动一次后，求当前指针i和j指向水柱之间的面积，更新一下最大值。\n为什么更新出来的值一定是最优解。 i和j最开始在两侧，每次把一个指针向中间靠拢，则一定有一侧指针会先到最优解的位置。假定指针i先到最优解位置，则指针j一定在其最优解位置的右边，并且指针j在到达最优解位置前每次指向的水柱高度严格小于最优解位置的高度。\n可以使用反证法证明。如果指针j当前指向的水柱高度大于等于其最优解位置的高度，则能装的水量一定大于最优解，就和最优解位置矛盾。因此，通过上述过程，一定可以遍历出最优解。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = 0; for (int i = 0, j = height.size() - 1; i \u0026lt; j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) i ++ ; else j -- ; } return res; } }; ","date":"2024-03-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/container-with-most-water/","title":"Container With Most Water"},{"content":"Similar Vocabulary high \u0026amp; tall high for things that are wider than their vertical height Sherlock Holmes fell from the top of a high building. I put the books on a high shelf. tall for things that are narrower than their vertical height Burj Khalifa is the tallest building in the world. My brother is six foot tall. big \u0026amp; large big for real and abstract things big city big house big decision big ideas large for real things with a more formal tone a large population a large number of projects a large amount of money Comparatives and Superlatives adjectives Comparatives Comparative adjectives tell us how something is different (the original smaller home of the BBC) or how something has changed (It\u0026rsquo;s busier than ever).\nHow do we form comparative adjectives?\nIn most cases, we add –er to the adjective to form a comparative (large - larger, fast - faster). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled when –er is added (big - bigger, fat - fatter). If the adjective ends with a consonant + y, we change the y to an i (busy - busier, funny - funnier). use ‘than’ to make a direct comparison with something else (I am taller than my brother.) Superlatives Superlative adjectives highlight something that is bigger, better or more than everything else (the largest live newsroom in Europe, the latest technology).\n** How do we form superlative adjectives?**\nwe add –est after the adjective. We also use ‘the’ before the adjective (fast - the fastest, large - the largest). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled (big - the biggest, fat - the fattest). If the adjective ends with a consonant + y, we change the y to an i (busy - the busiest, funny - the funniest). irregular forms adjective comparative superlative good etter (than) (the) best well better (than) (the) best bad worse (than) (the) worst ill worse (than) (the) worst far further (than) (the) furthest Much and more The comparatives and superlatives are different in these sentences. We use ‘more’ before the adjective to make a comparative form and ‘the most’ to make a superlative. because these adjectives have 2 syllables or more and they don’t end in ‘y’:\nThe new Broadcasting House was the most expensive project in BBC history. Having one central location makes the BBC more efficient. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. The new studios are more comfortable than the old ones. When we make comparisons, we sometimes also use ‘much’ or ‘a lot’ before the adjective for emphasis:\nThe new building is much nicer than the old one. I love this new furniture. It is a lot more comfortable than the old stuff. Our studios are much more modern now. My office is a lot bigger than before. It’s great! We do not use ‘much’ or ‘a lot’ with superlatives because they do not need extra emphasis! Comparing nouns When sentences compare nouns, not adjectives. We use ‘more than’ with a noun to mean ‘a greater number than’ and ‘the most’ with a noun to mean ‘the greatest number’.\nThe BBC reaches a worldwide audience of more than 150 million every week. New Broadcasting House has more departments than the old building. BBC One has the most viewers in the UK. We can use much and many for emphasis. And much more before an uncountable noun (like chocolate or money) and many more before a countable noun (like friends or countries).\nI feel sick. I ate much more chocolate than you. I have many more friends in my hometown than I do here. other forms of comparatives and superlatives one of the most \u0026hellip; Broadcasting House is one of the most iconic buildings in London. The BBC news team is one of the fastest in the world. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. \u0026hellip; as adjective as.. use the structure as + adjective + as to describe two things that are the same in some way.\nI am 3 years older than my brother but he is as tall as me. We are both 1m80 tall. Despite many changes over the years, the BBC is still as important as ever in the UK and around the world. All (of) the best it contains all the latest technology. == it is the most advanced studio in the world, not one of the most advanced. Broadcasting House contains all of the BBC\u0026rsquo;s most popular services. == All the best programmes are made in its studios. Even better \u0026ldquo;there are even more exciting things to see in the TV studios.\u0026rdquo; In this example, we use even for emphasis. For instance, we might say:\nThe original Broadcasting House was one of the BBC\u0026rsquo;s most important centres, but New Broadcasting House is even more important than before. The Beatles were one of Britain\u0026rsquo;s most famous bands when they played at Broadcasting House in 1963. However, they got even more popular later that year. Not as adjective as Paul McCartney is not as old as my grandfather. (means the grandfather is more older than Paul McCartney) Old Broadcasting House was not as modern as New Broadcasting House. (means New Broadcasting House is newer than the old building) ","date":"2023-09-07T00:00:00Z","image":"https://garfieldzhang.site/english-language.jpeg","permalink":"https://garfieldzhang.site/p/comparative-and-superlative/","title":"Comparative and Superlative"}]