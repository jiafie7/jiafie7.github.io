[{"content":"49. 字母异位词分组 分析 核心思想： 字母异位词在字母排序后，其排序结果是相同的。例如： \u0026quot;eat\u0026quot; 和 \u0026quot;tea\u0026quot; 排序后都为 \u0026quot;aet\u0026quot; 因此，可以将排序后的字符串作为键，将所有字母异位词分组存储在一个哈希表中 步骤： 遍历字符串数组，对每个字符串进行排序，得到其标准形式 将排序后的字符串作为键，将原始字符串加入到对应的哈希表键值中 遍历哈希表，提取所有的值（即字母异位词组） 时间复杂度 排序： 每个字符串排序的时间复杂度为 O(klogk) ，其中 k 是字符串的平均长度 总的排序复杂度为 O(n * klogk) ，其中 n 是字符串数组的大小 哈希表操作： 插入和查找操作的平均复杂度为 O(1) 总时间复杂度为 O(n * klogk)\n空间复杂度 哈希表存储：需要存储排序后的字符串和对应的原始字符串列表，空间复杂度为 O(n * k) 额外字符串副本：排序时需要创建字符串副本，额外空间复杂度为 O(k) 总空间复杂度为 O(n * k)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; groupAnagrams(std::vector\u0026lt;std::string\u0026gt;\u0026amp; strs) { std::vector\u0026lt;std::vector\u0026lt;std::string\u0026gt;\u0026gt; res; // 存储最终结果 std::unordered_map\u0026lt;std::string, std::vector\u0026lt;std::string\u0026gt;\u0026gt; hash; // 哈希表用于分组 // 遍历字符串数组 for (string str : strs) { std::string word = str; // 创建副本以便排序 std::sort(word.begin(), word.end()); // 排序字符串 hash[word].push_back(str); // 将原始字符串加入对应组 } // 遍历哈希表，将值部分（分组结果）加入结果 for (auto e : hash) res.push_back(e.second); return res; // 返回分组后的结果 } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/groupanagrams/","title":"groupAnagrams"},{"content":"128. 最长连续序列 分析 使用哈希集合 (unordered_set)：\n首先将数组中的所有元素存入一个哈希集合 s 中，便于快速判断某个数字是否存在 遍历数组，寻找序列起点：\n对于每个数字 start，如果 start - 1 不存在于集合中，说明它是某个连续序列的起点 从这个起点开始，逐步检查 start + 1, start + 2, … 是否存在于集合中，计算连续序列的长度 优化：删除已访问元素：\n在遍历过程中，一旦某个数字被处理，可以从集合中删除，避免后续重复处理 更新结果：\n记录所有连续序列的最大长度 时间复杂度 构建哈希集合：O(n) ，其中 n 是数组长度\n遍历数组：\n每个元素最多被访问两次（一次作为序列起点，一次作为序列中元素） 总复杂度为 O(n) 总时间复杂度为 O(n)\n空间复杂度 使用了一个哈希集合存储数组中的所有元素，空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: int longestConsecutive(std::vector\u0026lt;int\u0026gt;\u0026amp; nums) { std::unordered_set\u0026lt;int\u0026gt; s; // 哈希集合存储所有数字 for (int num : nums) s.insert(num); int res = 0; // 记录最长连续序列的长度 for (int start : nums) { // 如果 start 是序列的起点（前一个数字不存在） if (s.count(start) \u0026amp;\u0026amp; !s.count(start - 1)) { int end = start; // 初始化序列的起点 s.erase(end); // 移除起点，避免重复处理 // 找到当前序列的结尾 while (s.count(end + 1)) { end += 1; s.erase(end); // 同样移除，优化后续查询 } // 更新最长长度 res = std::max(res, end - start + 1); } } return res; } }; ","date":"2024-11-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longestconsecutivesequence/","title":"longestConsecutiveSequence"},{"content":"31. LRUCache 分析 LRU（Least Recently Used）是一种缓存替换策略，淘汰最久未被使用的数据，以保证缓存内存的有效利用率\n核心数据结构：\n双向链表：维护缓存访问顺序，最新使用的数据放在链表头，最久未使用的数据放在链表尾。双向链表的插入和删除操作可以在 O(1) 时间内完成，适用于缓存频繁更新的场景 哈希表：通过关键字快速定位链表中的节点 get(key)：\n若 key 存在，将对应节点移动到链表头，并返回其值 若 key 不存在，返回 -1 put(key, value)：\n若 key 已存在，更新其值并移动到链表头 若 key 不存在： 如果缓存已满，删除链表尾的节点（最久未使用） 将新节点插入到链表头 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class LRUCache { public: // 定义双向链表节点 struct Node { Node(int key, int value) : m_key(key), m_value(value) , prev(nullptr), next(nullptr) {} int m_key, m_value; Node *prev, *next; }; int n; // 缓存容量 Node *head, *tail; // 双链表的虚拟头节点 std::unordered_map\u0026lt;int, Node*\u0026gt; hash; // 哈希表，快速查找节点 // 初始化 LRU 缓存 LRUCache(int capacity) { n = capacity; head = new Node(-1, -1); // 创建虚拟头节点 tail = new Node(-1, -1); // 创建虚拟尾节点 head-\u0026gt;next = tail; // 初始化双向链表 tail-\u0026gt;prev = head; } // 从链表中删除指定节点 void remove(Node* cur) { cur-\u0026gt;next-\u0026gt;prev = cur-\u0026gt;prev; cur-\u0026gt;prev-\u0026gt;next = cur-\u0026gt;next; } // 在链表头部插入指定节点 void insert(Node* cur) { cur-\u0026gt;next = head-\u0026gt;next; cur-\u0026gt;prev = head; head-\u0026gt;next-\u0026gt;prev = cur; head-\u0026gt;next = cur; } // 获取节点的值 int get(int key) { if (!hash.count(key)) // 节点不存在 return -1; Node* cur = hash[key]; // 定位节点 remove(cur); // 更新节点在链表中的位置 insert(cur); return cur-\u0026gt;m_value; } // 插入或更新节点 void put(int key, int value) { if (hash.count(key)) // 节点已存在 { Node* cur = hash[key]; cur-\u0026gt;m_value = value; // 更新节点值 remove(cur); // 更新节点位置 insert(cur); } else // 节点不存在 { if (hash.size() == n) // 缓存已满 { Node* cur = tail-\u0026gt;prev; // 取出尾节点 remove(cur); // 从链表中移除 hash.erase(cur-\u0026gt;m_key); // 从哈希表中删除 } Node* cur = new Node(key, value); // 创建新节点 insert(cur); // 插入链表头 hash[key] = cur; // 添加到哈希表 } } }; ","date":"2024-11-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/lrucache/","title":"LRUCache"},{"content":"56. mergeIntervals 分析 排序： 首先将所有区间按照起始值从小到大排序。排序后，若两个区间有重叠，它们一定是相邻的 遍历与合并： 用变量 l 和 r 分别表示当前合并区间的起始和结束 遍历排序后的区间： 如果当前遍历区间的起始值大于当前合并区间的结束值 r，说明当前区间与前面的合并区间没有重叠，应将前面的合并区间加入结果，并更新 l 和 r 如果有重叠，则将 r 更新为当前区间结束值的较大值 遍历结束后，将最后一个合并区间加入结果 时间复杂度 排序：O(nlogn) ，n 是区间的数量 遍历：O(n)，每个区间只会被处理一次 总时间复杂度为 O(nlogn)\n空间复杂度 排序所需的额外空间复杂度为 O(logn) （排序算法的递归栈空间） 结果存储的空间复杂度为 O(n) 总空间复杂度为 O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; // 用于存储最终结果 if (intervals.empty()) return res; // 如果输入为空，直接返回空数组 // 1. 按区间的起始值排序 sort(intervals.begin(), intervals.end()); // 2. 初始化合并区间的左右边界 int l = intervals[0][0], r = intervals[0][1]; // 3. 遍历剩余区间 for (int i = 1; i \u0026lt; intervals.size(); ++ i) { // 当前区间的起始值 \u0026gt; 当前合并区间的结束值，说明没有重叠 if (r \u0026lt; intervals[i][0]) { res.push_back({l, r}); // 将当前合并区间加入结果 l = intervals[i][0]; // 更新新的合并区间的起始值 r = intervals[i][1]; // 更新新的合并区间的结束值 } else { // 如果有重叠，则更新当前合并区间的结束值 r = max(r, intervals[i][1]); } } // 将最后一个合并区间加入结果 res.push_back({l, r}); return res; } }; ","date":"2024-11-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/mergeintervals/","title":"mergeIntervals"},{"content":"152. maxProduct 分析 使用f[i - 1]记录所有以nums[i - 1]元素结尾的连续子数组中的最大乘积\n使用g[i - 1]记录所有以nums[i - 1]元素结尾的连续子数组中的最小乘积\n求f[i]\n当nums[i]为正数时，f[i] = std::max(nums[i], f[i - 1] * nums[i])，因为正数与最大值相乘，值最大，所以与f[i - 1]相乘 当nums[i]为负数时，f[i] = std::max(nums[i], g[i - 1] * nums[i])，因为负数与最小值相乘，值最大，所以与g[i - 1]相乘 求g[i]\n当nums[i]为正数时，g[i] = std::min(nums[i], g[i - 1] * nums[i])，因为正数与最小值相乘，值最小，所以与g[i - 1]相乘 当nums[i]为负数时，g[i] = std::min(nums[i], f[i - 1] * nums[i])，因为负数与最大值相乘，值最小，所以与f[i - 1]相乘 当nums[i]为0时，f[i]和g[i]都变为0，即连续子数组断开，从下一个元素重新开始找最大乘积\n优化：因为每次更新f[i]和g[i]只需要前一个数，所以不需要开两个数组记录所有值\n时间复杂度：O(n)\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: int maxProduct(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; int f_last = nums[0], g_last = nums[0]; for (int i = 1; i \u0026lt; nums.size(); ++ i) { int f_cur = f_last * nums[i], g_cur = g_last * nums[i]; f_last = std::max(nums[i], std::max(f_cur, g_cur)); g_last = std::min(nums[i], std::min(f_cur, g_cur)); res = std::max(res, f_last); } return res; } }; ","date":"2024-11-23T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/maxproduct/","title":"maxProduct"},{"content":"190. reverseBits 分析 核心步骤：取二进制数的第i位n \u0026gt;\u0026gt; i \u0026amp; 1\nres每次左移一位，然后将n的最低位加到res上\nC++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t res = 0; for (int i = 0; i \u0026lt; 32; ++ i) res = (res \u0026lt;\u0026lt; 1) + (n \u0026gt;\u0026gt; i \u0026amp; 1); return res; } }; ","date":"2024-11-23T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reversebits/","title":"reverseBits"},{"content":"33. Search in Rotated Sorted Array 分析 首先确定旋转数组后的分段情况，通过二分查找找到数组中旋转点的位置，即最大的元素所在的位置 根据旋转点的位置，将数组分为两段，根据 target 所在的段，重新调整指针 l 和 r 的位置 对 target 所在的段进行二分查找。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if (nums.empty()) return -1; int l = 0, r = nums.size() - 1; while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= nums[0]) l = mid; else r = mid - 1; } if (target \u0026gt;= nums[0]) l = 0; else l = r + 1, r = nums.size() - 1; while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (nums[mid] \u0026gt;= target) r = mid; else l = mid + 1; } if (nums[r] == target) return r; return -1; } }; ","date":"2024-04-03T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/search-in-rotated-sorted-array/","title":"Search in Rotated Sorted Array"},{"content":"32. Longest Valid Parentheses 分析 合法的括号序列一定满足： 前缀序列中，左括号数量 大于等于 右括号数量 左右括号数量相等 分段处理 对于序列中某个右括号的位置，如果满足当前位置是第一次右括号数大于左括号数的位置，那么该右括号位置就为一段的结尾。然后在每一段的内部更新最大合法序列长度。\n证明：任何一个合法括号序列都不会跨越两段 假设一个合法序列 s 跨越了两段 a 和 b。由于是合法序列，所以满足任意一个前缀序列中，左括号数量大于等于右括号数量。那么 s 对应 a 的前半段一定是左括号数量大于右括号数量的，而划分每一段时，结尾位置都是第一次右括号数大于左括号数的位置，而现在 s 对应的这段是左括号数大于右括号数。那么，a 去掉 s 对应的那段的剩余前半段一定是右括号数大于左括号数的，那 a 的结尾位置就不是第一次右括号数大于左括号数的位置，出现矛盾。\n每段内部找合法序列 由于右边界位置是第一次右括号数大于左括号数的位置，所以它前面的每一个右括号都一定能找到对应的左括号。因此，只要枚举以每个右括号为右端点的最长的一个合法括号序列的左端点是什么位置。\n对于每个右括号，找到最靠左的左括号位置可以用栈来做。\n从每一段起始位置开始，记录一下其实位置start，如果是左括号，就把它的下标入栈 否则（说明是右括号） 判断栈是否为空 不为空，出栈一个左括号 判断栈是否为空 不为空，则以当前右括号为右端点的合法区间的最靠左元素就是栈顶元素的下一个位置。它的长度是 i - 栈顶元素 为空，说明当前右括号的最靠左元素可以到起点位置。长度就是i - start 为空，说明对于当前右括号，左括号已经没有了，也就是第一个右括号数大于左括号的位置，这一段结束，更新下段起始位置start = i C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: int longestValidParentheses(string s) { stack\u0026lt;int\u0026gt; stk; int res = 0; for (int i = 0, start = -1; i \u0026lt; s.size(); i ++ ) { if (s[i] == \u0026#39;(\u0026#39;) stk.push(i); else { if (stk.size()) { stk.pop(); if (stk.size()) res = max(res, i - stk.top()); else res = max(res, i - start); } else { start = i; } } } return res; } }; ","date":"2024-04-02T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-valid-parentheses/","title":"Longest Valid Parentheses"},{"content":"31. Next Permutation 分析 首先，找到排列中从右往左第一个非递增的数字，记其索引为 k。 如果 k 为 0 或者更小，则说明当前排列已经是最大的排列，因此直接将整个排列反转即可得到最小的排列。 否则，从索引 k 开始往右查找，找到比索引 k-1 处元素大的最小元素，并将其与索引 k-1 处的元素交换。 最后，将索引 k 右侧的元素逆序排列，以确保得到的排列是比原排列大的下一个字典序排列。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int k = nums.size() - 1; while (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k - 1] \u0026gt;= nums[k]) k -- ; if (k \u0026lt;= 0) reverse(nums.begin(), nums.end()); else { int t = k; while (t \u0026lt; nums.size() \u0026amp;\u0026amp; nums[t] \u0026gt; nums[k - 1]) t ++ ; swap(nums[k - 1], nums[t - 1]); reverse(nums.begin() + k, nums.end()); } } }; ","date":"2024-04-01T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/next-permutation/","title":"Next Permutation"},{"content":"29. Divide Two Integers 分析 用位运算模拟除法过程\n例如，对于$\\frac{x}{y}=k$， 将k转换成2进制的形式，有$k = 2^{0} + 2^{1} + \u0026hellip; + 2^{31}$\n我们可以将每一位的值存下来，然后从高位向低位遍历，只要 x 大于当前位的值，x 就减去当前位的值\n又因为$x=yk=y2^0+y2^1+\u0026hellip;+y2^{31}$，所以每次 x 减去第i位的值时，最终要求得的商就加上 $2^{i}$\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: int divide(int dividend, int divisor) { typedef long long LL; vector\u0026lt;LL\u0026gt; exp; bool is_minus = false; if (dividend \u0026lt; 0 \u0026amp;\u0026amp; divisor \u0026gt; 0 || dividend \u0026gt; 0 \u0026amp;\u0026amp; divisor \u0026lt; 0) is_minus = true; LL a = abs((LL)dividend), b = abs((LL)divisor); for (LL i = b; i \u0026lt;= a; i = i + i) exp.push_back(i); LL res = 0; for (int i = exp.size() - 1; i \u0026gt;= 0; i -- ) { if (a \u0026gt;= exp[i]) { a -= exp[i]; res += (LL)1 \u0026lt;\u0026lt; i; } } if (is_minus) res = -res; if (res \u0026gt; INT_MAX) res = INT_MAX; if (res \u0026lt; INT_MIN) res = INT_MIN; return res; } }; ","date":"2024-03-30T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/divide-two-integers/","title":"Divide Two Integers"},{"content":"28. Find the Index of the First Occurrence in a String 分析 在源传和目标串首部添加一个字符，使得下标匹配从1开始，方便处理。 构建目标串的 next 数组。具体来说，对于目标串的任意位置 i，我们要找到一个数 j，使得 needle[1:j] 和 needle[i-j+1:i] 是相等的，并且 j 的值尽可能大。每个 next[i] 对应一个 j 。 遍历源串，在匹配过程中，若 haystack[i] 与 needle[j+1] 不相等，则将 j 回溯到 next[j]。若相等，则同时向后移动 i 和 j。若 j 移动到 needle 的末尾，则表示在 haystack 中找到了 needle，返回 i - m 即可。 时间复杂度为 O(n+m)，其中 n 和 m 分别是 haystack 和 needle 的长度。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int strStr(string haystack, string needle) { if (needle.empty()) return 0; int n = haystack.size(), m = needle.size(); haystack = \u0026#39; \u0026#39; + haystack, needle = \u0026#39; \u0026#39; + needle; vector\u0026lt;int\u0026gt; next(m + 1); for (int i = 2, j = 0; i \u0026lt;= m; i ++ ) { while (j \u0026amp;\u0026amp; needle[i] != needle[j + 1]) j = next[j]; if (needle[i] == needle[j + 1]) j ++ ; next[i] = j; } for (int i = 1, j = 0; i \u0026lt;= n; i ++ ) { while (j \u0026amp;\u0026amp; haystack[i] != needle[j + 1]) j = next[j]; if (haystack[i] == needle[j + 1]) j ++ ; if (j == m) return i - m; } return -1; } }; ","date":"2024-03-29T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/find-the-index-of-the-first-occurrence-in-a-string/","title":"Find the Index of the First Occurrence in a String"},{"content":"27. Remove Element C++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int k = 0; for (int i = 0; i \u0026lt; nums.size(); i ++ ) if (nums[i] != val) nums[k ++ ] = nums[i]; return k; } }; ","date":"2024-03-28T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-element/","title":"Remove Element"},{"content":"26. Remove Duplicates from Sorted Array 分析 用索引 k 记录非重复元素的位置。 判断当前元素 i 是否为第一个元素 或 是否与前一个元素不等。 如果满足上述条件，将当前元素复制到数组中索引为 k 的位置，然后递增 k。 最后返回索引 k，它表示移除重复元素后的数组长度。 C++代码 1 2 3 4 5 6 7 8 9 10 class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int k = 0; for (int i = 0; i \u0026lt; nums.size(); i ++ ) if (!i || nums[i] != nums[i - 1]) nums[k ++ ] = nums[i]; return k; } }; ","date":"2024-03-27T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-duplicates-from-sorted-array/","title":"Remove Duplicates from Sorted Array"},{"content":"25. Reverse Nodes in k-Group 分析 每k个节点为一段，每次循环先找到当前段的尾节点 q，如果 q 为 NULL，说明当前段不够k个节点，跳出循环。\n若q不为空，则对当前段进行反转。先反转段内的节点，定义两个指针 a 和 b 分别指向当前段的首节点和第二个节点。在每次循环中，将当前节点 b 的 next 指针指向前一个节点 a，然后更新 a 和 b。\n反转完成后，将当前段的首节点 p-\u0026gt;next 指向反转后的首节点 a，将原始的首节点 c 的 next 指针指向当前段的下一个节点 b。\n将指针 p 移动到下一个要反转的段的首节点处，即 p = c。\n时间复杂度为 O(N)，其中 N 是链表的长度，因为只需一次遍历即可完成每 k 个节点的反转。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; for (ListNode *p = dummy; ;) { ListNode *q = p; for (int i = 0; i \u0026lt; k \u0026amp;\u0026amp; q; i ++ ) q = q-\u0026gt;next; if (!q) break; ListNode *a = p-\u0026gt;next, *b = a-\u0026gt;next; for (int i = 0; i \u0026lt; k - 1; i ++ ) { ListNode *c = b-\u0026gt;next; b-\u0026gt;next = a; a = b, b = c; } ListNode *c = p-\u0026gt;next; p-\u0026gt;next = a; c-\u0026gt;next = b; p = c; } return dummy-\u0026gt;next; } }; ","date":"2024-03-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/reverse-nodes-in-k-group/","title":"Reverse Nodes in k-Group"},{"content":"24. Swap Nodes in Pairs C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode *dummy = new ListNode(-1); dummy-\u0026gt;next = head; for (ListNode* p = dummy; p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;next; ) { ListNode* a = p-\u0026gt;next; ListNode* b = a-\u0026gt;next; p-\u0026gt;next = b; a-\u0026gt;next = b-\u0026gt;next; b-\u0026gt;next = a; p = a; } return dummy-\u0026gt;next; } }; ","date":"2024-03-26T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/swap-nodes-in-pairs/","title":"Swap Nodes in Pairs"},{"content":"23. Merge k Sorted Lists 分析 用优先队列来维护当前 k 个链表中最小的元素。\n时间复杂度为 O(Nlogk)，其中 N 是所有链表节点的总数，k 是链表的数量，每次插入和删除操作的时间复杂度为 O(logk)，总共需要执行 N 次插入和删除操作。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct Cmp { bool operator() (ListNode* a, ListNode* b) { return a-\u0026gt;val \u0026gt; b-\u0026gt;val; } }; ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, Cmp\u0026gt; heap; ListNode *dummy = new ListNode(-1), *tail = dummy; for (ListNode* p: lists) if (p) heap.push(p); while (heap.size()) { ListNode* t = heap.top(); heap.pop(); tail = tail-\u0026gt;next = t; if (t-\u0026gt;next) heap.push(t-\u0026gt;next); } return dummy-\u0026gt;next; } }; ","date":"2024-03-25T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-k-sorted-lists/","title":"Merge k Sorted Lists"},{"content":"22. Generate Parentheses 分析 一个合法括号系列（只有一种括号时）的充分必要条件是：\n任意前缀序列中左括号数量大于等于右括号数量 左右括号数量相等 这里的左右括号数量一定是相等的，所以只要满足第一个条件就行了。\n如果不需要输出所有方案，只要方案数量的话，那就可以直接用公式 $\\frac{C_{2n}^{n}}{n+1}$ 求。\n假设当前位置为i，则该位置要么是左括号，要么是右括号。\n当0～i-1中的左括号数量小于n时，则位置i可以为左括号，否则不可以。 当0～i-1中的右括号数量小于n时，且前缀序列中左括号数量大于右括号数量，则位置i可以为右括号，否则不可以。 C++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: vector\u0026lt;string\u0026gt; res; vector\u0026lt;string\u0026gt; generateParenthesis(int n) { dfs(n, 0, 0, \u0026#34;\u0026#34;); return res; } void dfs(int n, int lc, int rc, string seq) { if (lc == n \u0026amp;\u0026amp; rc == n) res.push_back(seq); else { if (lc \u0026lt; n) dfs(n, lc + 1, rc, seq + \u0026#39;(\u0026#39;); if (rc \u0026lt; n \u0026amp;\u0026amp; rc \u0026lt; lc) dfs(n, lc, rc + 1, seq + \u0026#39;)\u0026#39;); } } }; ","date":"2024-03-24T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/generate-parentheses/","title":"Generate Parentheses"},{"content":"21. Merge Two Sorted Lists 分析 经典的二路归并算法，每次把两个链表中的较小值加入到新链表中。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode *dummy = new ListNode(-1); ListNode *cur = dummy; while (list1 \u0026amp;\u0026amp; list2) { if (list1-\u0026gt;val \u0026lt;= list2-\u0026gt;val) { cur = cur-\u0026gt;next = list1; list1 = list1-\u0026gt;next; } else { cur = cur-\u0026gt;next = list2; list2 = list2-\u0026gt;next; } } if (list1) cur-\u0026gt;next = list1; if (list2) cur-\u0026gt;next = list2; return dummy-\u0026gt;next; } }; ","date":"2024-03-22T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/merge-two-sorted-lists/","title":"Merge Two Sorted Lists"},{"content":"19. Remove Nth Node From End of List 分析 因为被删的可能是头节点，先建个虚拟头节点。\n要删除倒数第k个点，只要找到倒数第k+1个点的位置，将其指针指向k的next。\n因此先遍历一遍链表，得到链表长度。在遍历一次找到倒数第k+1个点。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(-1); dummy-\u0026gt;next = head; int len = 0; for (ListNode* p = dummy; p; p = p-\u0026gt;next) len ++ ; ListNode* p = dummy; for (int i = 0; i \u0026lt; len - n - 1; i ++ ) p = p-\u0026gt;next; p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; return dummy-\u0026gt;next; } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/remove-nth-node-from-end-of-list/","title":"Remove Nth Node From End of List"},{"content":"20. Valid Parentheses 分析 每次遇到一个左括号就加到栈里，每遇到一个右括号就和栈顶元素进行匹配。如果匹配，栈顶元素出栈，不匹配则不合法。最后判断下栈是否为空，为空则合法，否则不合法。\n一个小技巧是根据根据ASCII码来判断括号是否匹配，\u0026rsquo;(\u0026rsquo; 和 \u0026lsquo;)\u0026rsquo; 的值相差1，\u0026rsquo;[\u0026rsquo; 和 \u0026lsquo;]\u0026rsquo; 、 \u0026lsquo;{\u0026rsquo; 和 \u0026lsquo;}\u0026rsquo; 的值相差2。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public: bool isValid(string s) { stack\u0026lt;char\u0026gt; stk; for (char c: s) { if (c == \u0026#39;(\u0026#39; || c == \u0026#39;[\u0026#39; || c == \u0026#39;{\u0026#39;) stk.push(c); else { if (stk.size() \u0026amp;\u0026amp; abs(stk.top() - c) \u0026lt;= 2) stk.pop(); else return false; } } return stk.empty(); } }; ","date":"2024-03-21T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/valid-parentheses/","title":"Valid Parentheses"},{"content":"18. 4Sum 分析 与三数之和一样，只是这里要枚举两个位置 i 和 j。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: typedef long long LL; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1; j \u0026lt; nums.size(); j ++ ) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; for (int k = j + 1, l = nums.size() - 1; k \u0026lt; l; k ++ ) { if (k \u0026gt; j + 1 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) continue; while (l - 1 \u0026gt; k \u0026amp;\u0026amp; (LL)nums[i] + nums[j] + nums[k] + nums[l - 1] \u0026gt;= target) l -- ; if ((LL)nums[i] + nums[j] + nums[k] + nums[l] == (LL)target) { res.push_back({nums[i], nums[j], nums[k], nums[l]}); } } } } return res; } }; ","date":"2024-03-20T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/4sum/","title":"4Sum"},{"content":"17. Letter Combinations of a Phone Number 分析 经典的DFS问题，画个递归树，把过程转换成代码。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public: vector\u0026lt;string\u0026gt; res; string str[10] = { \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34; }; vector\u0026lt;string\u0026gt; letterCombinations(string digits) { if (digits.empty()) return res; dfs(digits, 0, \u0026#34;\u0026#34;); return res; } void dfs(string digits, int u, string path) { if (u == digits.size()) res.push_back(path); else { for (auto c: str[digits[u] - \u0026#39;0\u0026#39;]) dfs(digits, u + 1, path + c); } } }; ","date":"2024-03-19T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/letter-combinations-of-a-phone-number/","title":"Letter Combinations of a Phone Number"},{"content":"16. 3Sum Closest 分析 暴力做法就是三重循环，每种答案枚举一遍，求一个最接近的值。\n用双指针优化。先枚举位置i，对每一个位置j，找到一个最小的位置k使得 nums[i] + nums[j] + nums[k] \u0026gt;= target，这样可以得到大于等于target的最小值。并且，当k满足前述条件时，必然有 nums[i] + nums[j] + nums[k - 1] \u0026lt; target，也就可以得到小于target的最大值。每次更新下这两个值即可。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: int threeSumClosest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(), nums.end()); pair\u0026lt;int, int\u0026gt; res(INT_MAX, INT_MAX); for (int i = 0; i \u0026lt; nums.size(); i ++ ) for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++ ) { while (k - 1 \u0026gt; j \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= target) k -- ; int s = nums[i] + nums[j] + nums[k]; res = min(res, make_pair(abs(s - target), s)); if (k - 1 \u0026gt; j) { s = nums[i] + nums[j] + nums[k - 1]; res = min(res, make_pair(target - s, s)); } } return res.second; } }; ","date":"2024-03-18T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/3sum-closest/","title":"3Sum Closest"},{"content":"15. 3Sum 分析 首先将数组排序，每个答案数组包含三个数，而双指针只能处理两个位置，所以先枚举第一个数的位置。为了减少一些重复情况，我们设定 i \u0026lt; j \u0026lt; k。当i固定后，对于当前j，只需要找到最小的k使得 nums[i] + nums[j] + nums[k] \u0026gt;= 0。此时，若 nums[i] + nums[j] + nums[k] = 0， 则为答案数组。否则，由于 nums[i] + nums[j] + nums[k - 1] \u0026lt; 0，k不能再向左移动（递减），需要j向右移动（递增）。\n最后考虑避免重复情况。只需要保证i指向的下一个元素与当前元素不等即可，因为当前元素对应的答案数组已经被考虑过了。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; sort(nums.begin(), nums.end()); for (int i = 0; i \u0026lt; nums.size(); i ++ ) { if (i \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; for (int j = i + 1, k = nums.size() - 1; j \u0026lt; k; j ++ ) { if (j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j - 1]) continue; while (j \u0026lt; k - 1 \u0026amp;\u0026amp; nums[i] + nums[j] + nums[k - 1] \u0026gt;= 0) k -- ; if (nums[i] + nums[j] + nums[k] == 0) { res.push_back({nums[i], nums[j], nums[k]}); } } } return res; } }; ","date":"2024-03-17T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/3sum/","title":"3Sum"},{"content":"14. Longest Common Prefix 分析 首先看所有字符串第一个字符是否一样，一样则公共字符串长度至少为1，否则公共字符串为空。 再看第二个字符是否一样，这样一直遍历下去\u0026hellip; 最坏情况就是把所有字符串的每个字符枚举一遍，时间复杂度小于等于所有字符串之和。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { string res; if (strs.empty()) return res; for (int i = 0;; i ++ ) { if (i \u0026gt;= strs[0].size()) return res; char c = strs[0][i]; for (auto\u0026amp; str: strs) if (i \u0026gt;= str.size() || str[i] != c) return res; res += c; } return res; } }; ","date":"2024-03-16T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/longest-common-prefix/","title":"Longest Common Prefix"},{"content":"13. Roman to Integer 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 可以发现，除了4、9、40、90、400、900以外，其他的数字都可以通过加法得到。例如，80是LXXX，其中L是50，X是10，也就是 50 + 10 + 10 + 10 = 80。同理，300是CCC，C是100，所以有 100 + 100 + 100 = 300。\n而4、9、40、90、400、900可以通过减法得到。它们对应的罗马数字，前一个字符的数值都要比后一个字符数值小，并且改罗马数字的值等于后一个字符的数值减去前一个字符的数值。例如，40是XL，X是10，L是50，也就是 50 - 10 = 40。\n因此，只要每次看当前字符是否比后一个字符小，是的话就减去字符的值，否则就加上字符的值。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public: int romanToInt(string s) { unordered_map\u0026lt;char, int\u0026gt; hash; hash[\u0026#39;I\u0026#39;] = 1; hash[\u0026#39;V\u0026#39;] = 5; hash[\u0026#39;X\u0026#39;] = 10; hash[\u0026#39;L\u0026#39;] = 50; hash[\u0026#39;C\u0026#39;] = 100; hash[\u0026#39;D\u0026#39;] = 500; hash[\u0026#39;M\u0026#39;] = 1000; int res = 0; for (int i = 0; i \u0026lt; s.size(); i ++ ) { if (i + 1 \u0026lt; s.size() \u0026amp;\u0026amp; hash[s[i]] \u0026lt; hash[s[i + 1]]) res -= hash[s[i]]; else res += hash[s[i]]; } return res; } }; ","date":"2024-03-15T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/roman-to-integer/","title":"Roman to Integer"},{"content":"12. Integer to Roman 分析 1 2 3 4 5 6 7 8 9 I II III IV V VI VII VIII IX 10 20 30 40 50 60 70 80 90 X XX XXX XL L LX LXX LXXX XL 100 200 300 400 500 600 700 800 900 C CC CCC CD D DC DCC DCCC CM 1000 2000 3000 M MM MMM 1234 转换成罗马数字是 MCCXXXIV，也就是从千位到个位依次拼接，用代码将过程模拟出来即可。\n但是，可以找下规律。\n千位是1000～3000，把1000的M记下即可，只要当前数大于1000，就减去1000，换成一个M。\n百位的100～300记下C，每减100就换一个C。400无规律，单独记下CD。同理，500～800记下D，900记下CM。\n十位记下10、40、50、90，也就是X、XL、L、XC。个位记下1、4、5、9，也就是I、IV、V、IX。\n然后对记下的这些数字，从大到小去考虑。例如大于900，当前值减去900，字符串拼接一个CM。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: string intToRoman(int num) { int values[] = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 }; string romans[] = { \u0026#34;M\u0026#34;, \u0026#34;CM\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;CD\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;XC\u0026#34;, \u0026#34;L\u0026#34;, \u0026#34;XL\u0026#34;, \u0026#34;X\u0026#34;, \u0026#34;IX\u0026#34;, \u0026#34;V\u0026#34;, \u0026#34;IV\u0026#34;, \u0026#34;I\u0026#34; }; string res; for (int i = 0; i \u0026lt;= 12; i ++ ) { while (num \u0026gt;= values[i]) { res += romans[i]; num -= values[i]; } } return res; } }; ","date":"2024-03-14T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/integer-to-roman/","title":"Integer to Roman"},{"content":"11. Container With Most Water 分析 用两个指针i和j分别指向开头和结尾，如果指针i指向的水柱高度较低，则指针i向后移，反之指针j向前移。每移动一次后，求当前指针i和j指向水柱之间的面积，更新一下最大值。\n为什么更新出来的值一定是最优解。 i和j最开始在两侧，每次把一个指针向中间靠拢，则一定有一侧指针会先到最优解的位置。假定指针i先到最优解位置，则指针j一定在其最优解位置的右边，并且指针j在到达最优解位置前每次指向的水柱高度严格小于最优解位置的高度。\n可以使用反证法证明。如果指针j当前指向的水柱高度大于等于其最优解位置的高度，则能装的水量一定大于最优解，就和最优解位置矛盾。因此，通过上述过程，一定可以遍历出最优解。\nC++代码 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int res = 0; for (int i = 0, j = height.size() - 1; i \u0026lt; j; ) { res = max(res, min(height[i], height[j]) * (j - i)); if (height[i] \u0026lt; height[j]) i ++ ; else j -- ; } return res; } }; ","date":"2024-03-13T00:00:00Z","image":"https://garfieldzhang.site/leetcode.png","permalink":"https://garfieldzhang.site/p/container-with-most-water/","title":"Container With Most Water"},{"content":"Similar Vocabulary high \u0026amp; tall high for things that are wider than their vertical height Sherlock Holmes fell from the top of a high building. I put the books on a high shelf. tall for things that are narrower than their vertical height Burj Khalifa is the tallest building in the world. My brother is six foot tall. big \u0026amp; large big for real and abstract things big city big house big decision big ideas large for real things with a more formal tone a large population a large number of projects a large amount of money Comparatives and Superlatives adjectives Comparatives Comparative adjectives tell us how something is different (the original smaller home of the BBC) or how something has changed (It\u0026rsquo;s busier than ever).\nHow do we form comparative adjectives?\nIn most cases, we add –er to the adjective to form a comparative (large - larger, fast - faster). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled when –er is added (big - bigger, fat - fatter). If the adjective ends with a consonant + y, we change the y to an i (busy - busier, funny - funnier). use ‘than’ to make a direct comparison with something else (I am taller than my brother.) Superlatives Superlative adjectives highlight something that is bigger, better or more than everything else (the largest live newsroom in Europe, the latest technology).\n** How do we form superlative adjectives?**\nwe add –est after the adjective. We also use ‘the’ before the adjective (fast - the fastest, large - the largest). If the adjective finishes with a consonant-vowel-consonant pattern (like ‘big’), the final consonant is doubled (big - the biggest, fat - the fattest). If the adjective ends with a consonant + y, we change the y to an i (busy - the busiest, funny - the funniest). irregular forms adjective comparative superlative good etter (than) (the) best well better (than) (the) best bad worse (than) (the) worst ill worse (than) (the) worst far further (than) (the) furthest Much and more The comparatives and superlatives are different in these sentences. We use ‘more’ before the adjective to make a comparative form and ‘the most’ to make a superlative. because these adjectives have 2 syllables or more and they don’t end in ‘y’:\nThe new Broadcasting House was the most expensive project in BBC history. Having one central location makes the BBC more efficient. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. The new studios are more comfortable than the old ones. When we make comparisons, we sometimes also use ‘much’ or ‘a lot’ before the adjective for emphasis:\nThe new building is much nicer than the old one. I love this new furniture. It is a lot more comfortable than the old stuff. Our studios are much more modern now. My office is a lot bigger than before. It’s great! We do not use ‘much’ or ‘a lot’ with superlatives because they do not need extra emphasis! Comparing nouns When sentences compare nouns, not adjectives. We use ‘more than’ with a noun to mean ‘a greater number than’ and ‘the most’ with a noun to mean ‘the greatest number’.\nThe BBC reaches a worldwide audience of more than 150 million every week. New Broadcasting House has more departments than the old building. BBC One has the most viewers in the UK. We can use much and many for emphasis. And much more before an uncountable noun (like chocolate or money) and many more before a countable noun (like friends or countries).\nI feel sick. I ate much more chocolate than you. I have many more friends in my hometown than I do here. other forms of comparatives and superlatives one of the most \u0026hellip; Broadcasting House is one of the most iconic buildings in London. The BBC news team is one of the fastest in the world. The new ‘John Peel Wing’ is named after one of the BBC’s most popular presenters. \u0026hellip; as adjective as.. use the structure as + adjective + as to describe two things that are the same in some way.\nI am 3 years older than my brother but he is as tall as me. We are both 1m80 tall. Despite many changes over the years, the BBC is still as important as ever in the UK and around the world. All (of) the best it contains all the latest technology. == it is the most advanced studio in the world, not one of the most advanced. Broadcasting House contains all of the BBC\u0026rsquo;s most popular services. == All the best programmes are made in its studios. Even better \u0026ldquo;there are even more exciting things to see in the TV studios.\u0026rdquo; In this example, we use even for emphasis. For instance, we might say:\nThe original Broadcasting House was one of the BBC\u0026rsquo;s most important centres, but New Broadcasting House is even more important than before. The Beatles were one of Britain\u0026rsquo;s most famous bands when they played at Broadcasting House in 1963. However, they got even more popular later that year. Not as adjective as Paul McCartney is not as old as my grandfather. (means the grandfather is more older than Paul McCartney) Old Broadcasting House was not as modern as New Broadcasting House. (means New Broadcasting House is newer than the old building) ","date":"2023-09-07T00:00:00Z","image":"https://garfieldzhang.site/english-language.jpeg","permalink":"https://garfieldzhang.site/p/comparative-and-superlative/","title":"Comparative and Superlative"}]